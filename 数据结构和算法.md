# 问题数据结构与算法

## 数据结构的分类

### 逻辑性结构分类

逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类，也是我们后面课题中需要关注和讨论的问题。
	a.集合结构：集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系。

​		b.线性结构：线性结构中的数据元素之间存在一对一的关系

​	C.树形结构：树形结构中的数据元素之间存在一对多的层次关系

​	d.图形结构：图形结构的数据元素是多对多的关系

### 物理结构分类：

​	逻辑结构在计算机中真正的表示方式（又称为映像）称为物理结构，也可以叫做存储结构。常见的物理结构有顺序存储结构、链式存储结构。顺序存储结构：
把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的，比如我们常用的数组就是顺序存储结构。

​	顺序存储结构存在一定的弊端，就像生活中排时也会有人插队也可能有人有特殊情况突然离开，这时候整个结构都处于变化中，此时就需要链式存储结构。

#### 链式存储结构：

​	是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置

## 什么是算法

​	算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。

- 算法就是解决特定问题的一系列的执行步骤
- 使用不同的算法,解决同一个问题,效率可能相差非常的大  
- 数据结构是计算机存储、组织数据的方式 

## 数据结构的分类

- 线性结构
  - 线性表
  - 数组
  - 链表
  - 栈
  - 队列
  - 哈希表
- 树形结构
  - 二叉树
  - AVL树
  - 红黑树
  - B树
  - 堆
  - Trie
  - 哈夫曼树
  - 并查集  第一季不讲
- 图形结构
  - 邻接矩阵 第一季不讲
  - 领接表  第一季不讲

## 大O表示法(Big O)

一般用于大O表示法来描述复杂度,它表示的是数据规模n对应的复杂度

注意:大O表示法仅仅是一种粗略的分析模型,是一种估算,能帮助我们短时间内了解一个算法的执行效率

## 时间复杂度

### 常见的复杂度

![](D:\MD文档笔记\img\算法\时间复杂度.PNG)

![](D:\MD文档笔记\img\算法\时间复杂度大小.PNG)

## 斐波那契数列

### 算法一 - 递归

会有算法问题 数字越大计算越慢

```java
public static long fib(long a) {
        if (a <= 1) return a;
        return fib(a - 1) + fib(a - 2);
    }
```

### 算法二 - 循环

```java
public static long fib(long a) {
        if (a <= 1) return a;
        long first = 0;
        long second = 1;
        for (int i = 0; i < a - 1; i++) {
            long sum = first + second;
            second = sum;
            first = second;
        }
        return second;
    }
```

##  线性表

### 简介

线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。

前驱元素：
		若A元素在B元素的前面，则称A为B的前驱元素

后继元素：
		若B元素在A元素的后面，则称B为A的后继元素

**线性表的特征**：数据元素之间具有一种“一对一的逻辑关系。
	1.第一个数据元素没有前驱，这个数据元素被称为头结点；
	2.最后一个数据元素没有后继，这个数据元素被称为尾结点；
	3.除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。

如果把线性表用数学语言来定义，则可以表示为（a1ai-1，aiai+1an），ai-1领先于aiai领先于ai+1，称ai-1是ai的前驱元素，ai+1是ai
的后继元素

### 什么是线性表?

线性表是具有n个相同类型元素的有限序列 (n>=0)

![](D:\MD文档笔记\img\算法\线性表.PNG)

### 数组

**数组是一种顺序存储的线性表,所有元素的内存地址是连续的**

```java
int[] array = new int[] {11,22,33};
```

#### 注:

- 在跟多编程语言中,数组都有个致命的缺点
  - 无法动态修改容量
  - 可能会造成内存空间的大量浪费

## 动态数组的设计

```java
public class ArrayList<E> {
    /*
     * 动态数组的数量
     */
    private int size;
    /*
     * 动态数组的所有元素
     */
    private E[] elements;

    /*
     * 初始化数组的容量
     */
    private static final int DEFAULT_CAPACIIY = 2;

    /*
     * 默认错误的返回值
     */
    private static final int ELEMENT_NOT_FOUND = -1;

    /*
     * 有参数的构造方法
     */
    public ArrayList(int capaticy) {
        // 对数组的初始化的长度进行设置
        capaticy = (capaticy < DEFAULT_CAPACIIY) ? DEFAULT_CAPACIIY : capaticy;
        // 进行对数组的初始化设置
        elements = (E[]) new Object[capaticy];
    }

    /*
     * 无参数的构造发方法
     */
    public ArrayList() {
        // 调用有参数的构造方法进行设置 直接传入默认值
        this(DEFAULT_CAPACIIY);
    }

    /*
     * 清楚所有的元素
     */
    public void clear() {
        for (int i = 0; i < size; i++) {
            elements[i] = null;
        }
        size = 0;
    }

    /*
     * 元素的数量
     * @return
     */
    public int size() {
        return size;
    }

    /*
     * 是否为空
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }


    /*
     * 是否包含某个元素
     * @param element
     * @return
     */
    public boolean contains(E element) {
        return indexOf(element) != ELEMENT_NOT_FOUND;
    }

    /*
     * 根据index进行获取对应位置的元素
     * @param index
     * @return
     */
    public E get(int index) {
        return elements[index];
    }

    /**
     * 设置index位置的元素
     *
     * @param index
     * @param element
     * @return
     */
    public E set(int index, E element) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("数组越界异常！");
        }
        //取出原来的元素进行赋值
        E old = elements[index];
        //对新的元素进行赋值
        elements[index] = element;
        //返回旧的数据
        return old;
    }

    /**
     * 添加到数组的尾部
     *
     * @param element
     */
    public void add(E element) {
        add(size, element);
    }

    /**
     * 在指定位置插入指定的数据
     *
     * @param index
     * @param element
     */
    public void add(int index, E element) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("数组越界异常！");
        }
        ensureCapacity(size + 1);
        for (int i = size; i > index; i--) {
            elements[i] = elements[i - 1];
        }
        elements[index] = element;
        size++;
    }

    /**
     * 查看元素第一次出现的索引
     *
     * @param element
     * @return
     */
    public int indexOf(E element) {
        if (element == null) {
            for (int i = 0; i < size; i++) {
                if (elements[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(elements[i])) {
                    return i;
                }
            }
        }

        return ELEMENT_NOT_FOUND;
    }


    /**
     * 删除数组对应index里面的元素
     *
     * @param index
     * @return
     */
    public E remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("数组越界异常！");
        }
        E old = elements[index];
        for (int i = index + 1; i < size; i++) {
            elements[i - 1] = elements[i];
        }
        size--;
        elements[size] = null;
        return old;
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("ArrayList{ size = ").append(size).append(", elements = [");
        for (int i = 0; i < size; i++) {
            string.append(elements[i]);
            if (i != size - 1) {
                string.append(",");
            }
        }
        string.append("] }");
        return string.toString();
    }

    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;
        int newCapacity = oldCapacity + (oldCapacity << 1);
        E[] newElements = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;
    }
}
```

## 链表

### 单项链表的设计

**链表是一种连式存储的线性表,所有元素的内存地址不一定是连续的**

链表是一种物理存储单元上非连续、非顺序的存储结构，其物理结构不能只管的表示数据元素的逻辑顺序，数据元素的逻辑顺序是通
过链表中的指针链接次序实现的。链表由一系列的结点（链表中的每一个元素称为结点）组成，结点可以在运行时动态生成

#### 接口设计

**链表的大部分接口和动态数组是一致的**

1. List接口
2. LinkedList类
3. 抽象类AbstractList

```java
package cn.doudou;

public interface List<E>{
    /*
     * 默认错误的返回值
     */
    static final int ELEMENT_NOT_FOUND = -1;

    /**
     * 清楚所有的元素
     */
    void clear();

    /**
     * 元素的数量
     * @return
     */
    int size();

    /**
     * 是否为空
     * @return
     */
    boolean isEmpty();

    /**
     * 是否包含某个元素
     * @return
     */
    boolean contains(E element);

    /**
     * 插入元素
     * @param element
     */
    void add(E element);

    /**
     * 获得index位置的元素
     * @param index
     * @return
     */
    E get(int index);

    /**
     * 设置某个位置的元素
     * @param index
     * @param element
     * @return
     */
    E set(int index,E element);

    /**
     * 插入指定位置的元素
     * @param index
     * @param element
     */
    void add(int index,E element);

    /**
     * 删除对应index位置的元素
     * @param index
     * @return
     */
    E remove(int index);

    /**
     * 查看元素第一次出现的位置
     * @param element
     * @return
     */
    int indexOf(E element);
}

```

```java
package cn.doudou;

public class LinkedList<E> extends AbstractList<E> {

    private Node<E> first;

    @Override
    public void clear() {
        size = 0;
        first = null;
    }

    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        if (index == 0) {
            first = new Node<>(element, first);
        } else {
            Node<E> prev = node(index - 1);
            prev.next = new Node<>(element, prev.next);
        }
        size++;
    }

    @Override
    public E remove(int index) {
        rangeCheck(index);
        Node<E> oldNode = first;
        if (index == 0) {
            this.first = this.first.next;
        } else {
            Node<E> node = node(index - 1);
            oldNode = node.next;
            node.next = node.next.next;
        }
        size--;
        return oldNode.element;
    }

    @Override
    public int indexOf(E element) {
        Node<E> node = this.first;
        if (element == null) {
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(node.element)) return i;
                node = node.next;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    /**
     * 内部类
     *
     * @param <E>
     */
    private static class Node<E> {
        E element;
        Node<E> next;

        public Node(E element, Node<E> next) {
            this.element = element;
            this.next = next;
        }
    }

    private Node<E> node(int index) {
        rangeCheck(index);
        Node<E> node = first;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("LinkedList{ size = ").append(size).append(", elements = [");
        Node<E> node = this.first;
        for (int i = 0; i < size; i++) {
            string.append(node.element);
            node = node.next;
            if (i != size - 1) {
                string.append(",");
            }
        }
        string.append("] }");
        return string.toString();
    }
}

```

```java
package cn.doudou;

public abstract class AbstractList <E> implements List<E>{
    protected int size;


    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean contains(E element) {
        return indexOf(element) != ELEMENT_NOT_FOUND;
    }

    public void add(E element) {
        add(size, element);
    }


    /**
     * 检查数组的index是不是越界
     *
     * @param index
     */
    protected void outOfBounds(int index) {
        throw new IndexOutOfBoundsException("数组越界异常!");
    }

    protected void rangeCheck(int index) {
        if (index < 0 || index >= size) {
            outOfBounds(index);
        }
    }

    protected void rangeCheckForAdd(int index) {
        if (index < 0 || index > size) {
            outOfBounds(index);
        }
    }

}

```

#### 虚拟头结点

有时候为了让代码更加的精简,统一所有的节点的处理逻辑,可以在前面加一个虚拟的节点(不存储数据)

```java
package cn.doudou;

/**
 * 虚拟头节点的实现方式
 *
 * @param <E>
 */
public class LinkedList2<E> extends AbstractList<E> {

    private Node<E> first;

    public LinkedList2() {
        first = new Node<>(null, null);
    }

    @Override
    public void clear() {
        size = 0;
        first = null;
    }

    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        Node<E> prev = index == 0 ? first : node(index - 1);
        prev.next = new Node<>(element, prev.next);
        size++;
    }

    @Override
    public E remove(int index) {
        rangeCheck(index);
        Node<E> node = index == 0 ? first : node(index - 1);
        Node<E> oldNode = node.next;
        node.next = node.next.next;

        size--;
        return oldNode.element;
    }

    @Override
    public int indexOf(E element) {
        Node<E> node = this.first;
        if (element == null) {
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(node.element)) return i;
                node = node.next;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    /**
     * 内部类
     *
     * @param <E>
     */
    private static class Node<E> {
        E element;
        Node<E> next;

        public Node(E element, Node<E> next) {
            this.element = element;
            this.next = next;
        }
    }

    private Node<E> node(int index) {
        rangeCheck(index);
        Node<E> node = first.next;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("LinkedList{ size = ").append(size).append(", elements = [");
        Node<E> node = this.first.next;
        for (int i = 0; i < size; i++) {
            string.append(node.element);
            node = node.next;
            if (i != size - 1) {
                string.append(",");
            }
        }
        string.append("] }");
        return string.toString();
    }
}

```

### 双向链表的设计

1. 此前所学的链表,也叫做单项链表
2. 使用双向链表可以提升链表的综合性能

#### 简介



![image-20220511165654283](D:\MD文档笔记\img\算法\双向链表.png)

#### 代码

```java
package cn.doudou;

/**
 * 双向链表的实现
 */
public class LinkedList<E> extends AbstractList<E> {

    /**
     * 指向链表的头结点
     */
    private Node<E> first;
    /**
     * 指向链表的尾节点
     */
    private Node<E> last;

    @Override
    public void clear() {
        size = 0;
        first = null;
        last = null;
    }

    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        if (index == size) {
            Node<E> oldLast = last;
            last = new Node<>(oldLast, element, null);
            //即使第一个元素也是最后一个元素
            if (oldLast == null) {
                first = last;
            } else {
                oldLast.next = last;
            }
        } else {
            //找到需要进行插入的链表
            Node<E> next = node(index);
            //找到上一个链表
            Node<E> prev = next.prev;
            //构建一个Node节点进行插入
            Node node = new Node(prev, element, next);
            /**
             * 我们首先对插入的元素的prev的上一个元素进行相连接的操作
             */
            next.prev = node;
            if (prev == null) {
                first = node;
            } else {
                /**
                 * 我们对元素的下一个元素的上一个指针进行连接的操作
                 */
                prev.next = node;
            }
        }
        /**
         * 最后我们对链表的数量进行加++的操作
         */
        size++;
    }

    @Override
    public E remove(int index) {
        rangeCheck(index);

        Node<E> node = node(index);
        Node<E> next = node.next;
        Node<E> prev = node.prev;

        if (prev == null) { //index == 0
            first = next;
        } else {
            prev.next = next;
        }

        if (next == null) {//index == size-1
            last = prev;
        } else {
            next.prev = prev;
        }
        size--;
        return node.element;
    }

    @Override
    public int indexOf(E element) {
        Node<E> node = this.first;
        if (element == null) {
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(node.element)) return i;
                node = node.next;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    /**
     * 内部类
     *
     * @param <E>
     */
    private static class Node<E> {
        E element;
        Node<E> prev;
        Node<E> next;

        public Node(Node<E> prev, E element, Node<E> next) {
            this.prev = prev;
            this.element = element;
            this.next = next;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();

            if (prev != null) {
                sb.append(prev.element);
            } else {
                sb.append("null");
            }
            sb.append("_").append(element).append("_");

            if (next != null) {
                sb.append(next.element);
            }else {
                sb.append("null");
            }
            return sb.toString();
        }
    }

    private Node<E> node(int index) {
        rangeCheck(index);

        /**
         * 我们这里进行判断
         * 主要实现的思路为
         * 判断index的是否小于size/2的数值 如果是就从左边开始查找,不是的话就从右边开始查找,等于的情况随便都可以
         */
        if (index < (size >> 1)) {
            Node<E> node = first;
            for (int i = 0; i < index; i++) {
                node = node.next;
            }
            return node;
        } else {
            Node<E> node = last;
            for (int i = size - 1; i > index; i--) {
                node = node.prev;
            }
            return node;
        }
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("LinkedList{ size = ").append(size).append(", elements = [");
        Node<E> node = this.first;
        for (int i = 0; i < size; i++) {
            if (i != 0) {
                string.append(",");
            }
            string.append(node);
            node = node.next;
        }
        string.append("]");
        return string.toString();
    }
}

```

### 双向链表VS动态数组

- 动态数组: 开辟、销毁内存空间的次数相对较少,但可能造成内存的空间的浪费(可以通过缩容进行解决)
- 双向链表：开辟、销毁内存空间的此次数相对较多,但不会造成内存空间的浪费

1. 如果频繁在尾部进行添加 删除操作 动态数组 双向链表均可选择
2. 如果频繁在头部进行添加 删除操作 建议选择使用双向链表
3. 如果有频繁的在任意位置 添加 删除操作 建议选择使用双向链表
4. 如果有频繁的查询操作随机访问操作 建议选择使用动态数组

### 链表的复杂度分析

get（inti:每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素N的增多，比较的元素越多，时间复杂度为O（n）
insert（inti.Tt:每一次插入，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂
度为O（n）；
remove（inti:每一次移除，需要先找到位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂
度为O（n）
相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的，它不需要预先指定
存储空间大小，或者在存储过程中涉及到扩容等操作，同时它并没有涉及的元素的交换。
相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议
使用链表。

### 链表反转

单链表的反转，是面试中的一个高频题目。

**需求**：
		原链表中数据为：1->2->3>4
		反转后链表中数据为：4->3->2->1
**反转API：**

`public void reverse（）：对整个链表反转`

`public Node reverse（Nodecurr）：反转链表中的某个结点curr，并把反转后的curr结点返回`

使用递归可以完成反转，递归反转其实就是从原链表的第一个存数据的结点开始，依次递归调用反转每一个结点，直到把最后一个结
点反转完毕，整个链表就反转完毕。

##### 代码

```java
 //用来反转整个链表
    public void reverse() {
        //判断链表是否为空
        if (isEmpty()) {
            return;
        }
        reverse(head.next);
    }

    //反转指定的结点curr，并把反转后的结点返回
    public Node reverse(Node curr) {
        if (curr.next == null) {
            //头部结点的下一个节点等于curr
            head.next = curr;
            return curr;
        }
        Node pre = reverse(curr.next);
        pre.next = curr;
        curr.next = null;
        return curr ;
    }
```

### 快慢指针

#### 中间值问题

**代码**

```java
    /**
     * @param first 链表的首结点
     * @return 链表的中间结点的值
     */
    public static String getMid(Node<String> first) {
        //定义两个指针
        Node fast = first;
        Node slow = first;
        //当快指针指向的节点没有下一个节点了就结束了 返回慢指针的值
        while (fast != null && fast.next != null) {
            //变换fast和slow的节点
            fast = fast.next.next;
            slow = slow.next;
        }
        return (String) slow.item;
    }
```

#### 单项链表是否有环

**代码**

```java
/**
     * 判断链表中是否有环
     * @param first 链表首结点
     * @return ture为有环，false为无环
     */
    public static boolean isCircle(Node<String> first) {
        //定义快慢指针
        Node<String> fast = first;
        Node<String> slow = first;

        //遍历链表，如果快慢指针指向了同一个结点，那么证明有环
        while(fast!=null && fast.next!=null){
            //变换fast和slow
            fast = fast.next.next;
            slow = slow.next;

            if (fast.equals(slow)){
                return true;
            }
        }

        return false;
    }
```

#### 有环链表入口

**代码**

```java
/**
     * 查找有环链表中环的入口结点
     *
     * @param first 链表首结点
     * @return 环的入口结点
     */
    public static Node getEntrance(Node<String> first) {
        //定义快慢指针
        Node<String> fast = first;
        Node<String> slow = first;
        Node<String> temp = null;

        //遍历链表，先找到环(快慢指针相遇),准备一个临时指针，指向链表的首结点，继续遍历，直到慢指针和临时指针相遇，那么相遇时所指向的结点就是环的入口
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;

            if (fast.equals(slow)) {
                temp = first;
                continue;
            }
            //让临时节点变换
            if (temp != null) {
                temp = temp.next;
                //判断临时指针是否和慢指针相遇
                if (temp.equals(slow)) {
                    break;
                }
            }
        }
        return temp;
    }
```

### 循环链表

循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结点，因为没有下一个元
素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。

![](D:\MD文档笔记\img\算法\环形链表.png)

**代码**

```java
public static void main(String[] args) throws Exception {
        Node<String> first = new Node<String>("aa", null);
        Node<String> second = new Node<String>("bb", null);
        Node<String> third = new Node<String>("cc", null);
        Node<String> fourth = new Node<String>("dd", null);
        Node<String> fifth = new Node<String>("ee", null);
        Node<String> six = new Node<String>("ff", null);
        Node<String> seven = new Node<String>("gg", null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
        //构建循环链表，让最后一个结点指向第一个结点

        seven.next = first;
    }
```

### 约瑟夫问题

**问题描述：**

传说有这样一个故事，在罗马人占领乔塔帕特后，39个犹太人与约瑟夫及他的朋友熟到一个洞中，39个犹太人决定宁愿死也不要被敌
人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次往后，如果有人报数到3，那么这个人就必须
自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡为止。然而约琴夫和他的朋友并不想遵从。于是，约瑟夫要他
的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，从而逃过了这场死亡游戏。

**问题转换：**

41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。
1.编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈；
2.自退出那个人开始的下一个人再次从1开始报数，以此类推；
3.求出最后退出的那个人的编号

```java
 public static void main(String[] args) {
        //约瑟夫问题
        //构建循环链表
        //存储首个节点
        Node<Integer> first = null;
        //存储记录的前一个节点
        Node<Integer> pre = null;
        for (int i = 1; i <= 41; i++) {
            //如果是首节点
            if (i == 1) {
                first = new Node<>(i, null);
                pre = first;
                continue;
            }
            //如果不是首节点
            Node<Integer> newNode = new Node<>(i, null);
            pre.next = newNode;
            pre = newNode;
            //如果是尾节点
            if (i == 41) {
                pre.next = first;
            }
        }
        //需要count计数器 模拟报数
        int count = 0;
        //遍历循环列表
        //记录每次拿到的节点 默认从首节点开始
        Node<Integer> n = first;
        //记录当前节点的上一个节点
        Node<Integer> before = null;
        while (n != n.next) {
            //模拟报数
            count++;
            //判断当前报数是不是3
            if (count == 3) {
                //如果是3就删除节点并打印节点 重置计数器 让当前节点进行后移
                before.next = n.next;
                System.out.print(n.item + ",");
                count = 0;
                n = n.next;
            } else {
                //如果不是3就让当前节点后移 让before变成当前节点
                before = n;
                n = n.next;
            }
        }
        System.out.println(n.item);
    }
```

## 栈

### 生活中的栈

存储货物或供旅客住宿的地方，可引申为仓库、中转站。例如我们现在生活中的酒店，在古时候叫客栈，是供旅客休息的地方，旅客可以进客栈休息，休息完毕后就离开客栈

### 计算机中的栈

我们把生活中的栈的概念引入到计算机中，就是供数据休息的地方，它是一种数据结构，数据既可以进入到栈中，又可以从栈中出
去。
栈是一种基于先进后出（FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先
进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。

我们称数据进入到栈的动作为**压栈**，数据从栈中出去的动作为**弹栈**

![](D:\MD文档笔记\img\算法\栈.png)

### 栈API的设计与实现

| 类名       | Stack<T>                                                     |
| ---------- | ------------------------------------------------------------ |
| 构造方法   | Stack)：创建Stack对象                                        |
| 成员方法   | 1.public boolean isEmpy()：判断栈是否为空，是返回wrue，否返回false<br/>2.public intsize(): 获取栈中元素的个数<br/>3.public Tpop(): 弹出栈顶元素<br/>4.public void push(T t）：向栈中压入元素t |
| 成员变量   | 1.private Node head:记录首结点<br/>2.private int N:当前栈的元素个数 |
| 成员内部类 | private class Node：节点类                                   |

### 栈代码实现

```java
package cn.doudou.algorithm.linear;

import javax.xml.soap.Node;
import java.util.Iterator;

/**
 * Create By 王嘉浩
 * Time 2022-09-20 16:59
 * 栈的实现
 */
public class Stack<T> implements Iterable<T> {
    //记录首节点
    private Node head;
    //栈中元素的个数
    private int N;


    /**
     * Node的节点内部类
     */
    private class Node {
        public T item;
        public Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    /**
     * 初始化栈内部的元素
     */
    public Stack() {
        this.head = new Node(null, null);
        this.N = 0;
    }

    /**
     * 判断栈中元素的个数是不是为0
     *
     * @return boolean
     */
    public boolean isEmpty() {
        return N == 0;
    }

    /**
     * 获取栈中元素的个数
     *
     * @return int
     */
    public int size() {
        return N;
    }

    /**
     * 把元素t压入栈中
     *
     * @param t
     */
    public void push(T t) {
        //找到首节点指向的第一个节点
        Node oldFirst = head.next;
        //创建新的节点
        Node newNode = new Node(t, null);
        //让首节点指向新的节点
        head.next = newNode;
        //让新的节点指向原来第一个节点
        newNode.next = oldFirst;
        //元素个数+1
        N++;
    }

    /**
     * 弹出定栈元素
     *
     * @return T
     */
    public T pop() {
        //找到首节点指向的第一个节点
        Node oldFirst = head.next;
        if (oldFirst == null) {
            return null;
        }
        //修改head的next的指向
        head.next = oldFirst.next;
        //元素个数-1
        N--;
        //弹出元素
        return oldFirst.item;
    }


    @Override
    public Iterator<T> iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator {
        private Stack.Node n;

        public SIterator() {
            this.n = head;
        }

        @Override
        public boolean hasNext() {
            return n.next != null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}
```

### 括号匹配问题

**问题描述:**

```
给定一个字符串，里边可能包含“（）“小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。
例如：
“（上海）（长安）”：正确匹配
“上海（（长安））”：正确匹配
“上海（长安（北京）（深圳）南京）”：正确匹配
“上海（长安））”：错误匹配
“（（上海）长安”：错误匹配
```

代码:



```java
package cn.doudou.algorithm.test;

import cn.doudou.algorithm.linear.Stack;

/**
 * Create By 王嘉浩
 * Time 2022-10-18 10:38
 */
public class BracketsMatchTest {
    public static void main(String[] args) {
        String str = "(上海(长安))";
        boolean match = isMatch(str);
        System.out.println(match);
    }

    private static boolean isMatch(String str) {
        //1.创建栈对象
        Stack<String> chars = new Stack<>();
        //2.循环遍历字符串的每个字符
        for (int i = 0; i < str.length(); i++) {
            String currChar = str.charAt(i) + "";
            //3.判断字符是不是等于左侧括号是的话就向栈里面进行添加一个左括号
            if (currChar.equals("(")) {
                chars.push(currChar);
            }
            //4.判断是不是右括号是的话就弹出一个左括号
            if (currChar.equals(")")) {
                String pop = chars.pop();
                //5.判断弹出的元素是否成功
                if (pop == null) {
                    return false;
                }
            }
        }
        //6.判断栈中是否还有左括号,如果有,证明不匹配.没有则匹配
        if (chars.size() == 0) {
            return true;
        } else {
            return false;
        }
    }
}

```

### 逆波兰表达式求值

逆波兰表达式求值问题是我们计算机中经常遇到的一类问题，要研究明白这个问题，首先我们得搞清楚什么是逆波兰表达式？要搞清楚逆波兰表达式，我们得从中缀表达式说起。
**中缀表达式：**
中缀表达式就是我们平常生活中使用的表达式，例如：1+3*2.2-（1+3）等等，中缀表达式的特点是：二元运算符总是置于两个操作数中间。
中经表达式是人们最喜欢的表达式方式，因为简单，易懂。但是对于计算机来说就不是这样了，因为中缀表达式的运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中表达式，需要解析表达式语义，做大量的优先级相关操作。
**逆波兰表达式（后缓表达式）：**
逆波兰表达式是波兰逻辑学家]·卢卡西维兹（·Lukasewicz）于1929年首先提出的一种表达式的表示方法，后缀表达式的特点：运算符总是放在跟它相关的操作数之后。

| 中缀表达式 | 逆波兰表达式 |
| :--------: | :----------: |
|    a+b     |     ab+      |
|  a+(b-c)   |    abc-+     |
| a+(b-c)*d  |   abc-d*+    |
| a*(b-c)+d  |   abc-*d+    |

#### 代码:

```java
package cn.doudou.algorithm.test;

import cn.doudou.algorithm.linear.Stack;

/**
 * Create By 王嘉浩
 * Time 2022-10-18 10:38
 */
public class BracketsMatchTest {
    public static void main(String[] args) {
        String str = "(上海(长安))";
        boolean match = isMatch(str);
        System.out.println(match);
    }

    private static boolean isMatch(String str) {
        //1.创建栈对象
        Stack<String> chars = new Stack<>();
        //2.循环遍历字符串的每个字符
        for (int i = 0; i < str.length(); i++) {
            String currChar = str.charAt(i) + "";
            //3.判断字符是不是等于左侧括号是的话就向栈里面进行添加一个左括号
            if (currChar.equals("(")) {
                chars.push(currChar);
            }
            //4.判断是不是右括号是的话就弹出一个左括号
            if (currChar.equals(")")) {
                String pop = chars.pop();
                //5.判断弹出的元素是否成功
                if (pop == null) {
                    return false;
                }
            }
        }
        //6.判断栈中是否还有左括号,如果有,证明不匹配.没有则匹配
        if (chars.size() == 0) {
            return true;
        } else {
            return false;
        }
    }
}

```

## 队列

队列是一种基于先进先出（FIFO）的数据结构，是一种只能在一端进行插入在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。

![](D:\MD文档笔记\img\算法\队列介绍.png)

### 队列的API设计

| 类名       | Queue<T>                                                     |
| ---------- | ------------------------------------------------------------ |
| 构造方法   | Queue(）：创建Queue对象                                      |
| 成员方法   | 1.public booleanisEmpty()：判断队列是否为空，是返回true，否返回false<br/>2.public intsize()获取队列中元素的个数<br/>3.public Tdequeue():从队列中拿出一个元素<br/>4.public void engueue(T t）：往队列中插入一个元素 |
| 成员变量   | 1.private Node head:录自结点<<br/>2.private int N:当前栈的元素个数<br/>3.private Node last记录最后一个结点 |
| 成员内部类 | private class Node结点类                                     |

### 代码

```java
package cn.doudou.algorithm.linear;

import java.util.Iterator;

public class Queue<T> implements Iterable<T> {
    //记录首结点
    private Node head;
    //记录最后一个结点
    private Node last;
    //记录队列中元素的个数
    private int N;


    private class Node {
        public T item;
        public Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    public Queue() {
        this.head = new Node(null, null);
        this.last = null;
        this.N = 0;
    }

    //判断队列是否为空
    public boolean isEmpty() {
        return N == 0;
    }

    //返回队列中元素的个数
    public int size() {
        return N;
    }

    //向队列中插入元素t
    public void enqueue(T t) {
        if (last == null) {
            //last为null
            last = new Node(t, null);
            head.next = last;
        } else {
            //last不为null
            Node oldLast = last;
            last = new Node(t, null);
            oldLast.next = last;
        }
        N++;
    }

    //从队列中拿出一个元素
    public T dequeue() {
        if (isEmpty()) {
            return null;
        }
        Node oldNode = head.next;
        head.next = oldNode.next;
        N--;
        if (isEmpty()) {
            last = null;
        }
        return oldNode.item;
    }


    @Override
    public Iterator<T> iterator() {
        return new QIterator();
    }

    private class QIterator implements Iterator {
        private Node n;

        public QIterator() {
            this.n = head;
        }

        @Override
        public boolean hasNext() {
            return n.next != null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}
```

## 符号表

符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值。

![](D:\MD文档笔记\img\算法\符号表.png)

符号表中，键具有唯一性。
符号表在实际生活中的使用场景是非常广泛的，见下表:

| 应用     | 查找目的                 | 键     | 值       |
| -------- | ------------------------ | ------ | -------- |
| 字典     | 找出单词的释义           | 单词   | 释义     |
| 图书索引 | 找出某个术语相关的页码   | 术语   | 一串页码 |
| 网络搜索 | 找出某个关键字对应的网页 | 关键字 | 网页名称 |

### 符号表API设计

**节点类:**

| 类名     | Node<Key,Value>                                              |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(Key key.Value value,Node next）：创建Node对象           |
| 成员变量 | 1.public Key key存储键<br/>2.public value value存储值<br/>3.public Node next存储下一个结点 |

**符号表:**

| 类名     | SymbolTabl<Key,Value>                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | SymbolTable()：创建SymbolTable对象                           |
| 成员方法 | 1.public Value get(key key)：根据键key，找对应的值<br/>2public void put(Key key,Value val):向符号表中插入一个键值对<br/>3.public void delete(Key key)删除键为key的键值对<br/>4.public int size()：获取符号表的大小 |
| 成员变量 | 1.private Node head:记录首结点 <br/>2.private int N:记录符号表中键值对的个数 |

### 符号表实现

```java
package cn.doudou.algorithm.symbol;

/**
 * Create By 王嘉浩
 * Time 2022-10-23 15:02
 * <p>
 * 符号表的设计与实现
 */

public class SymbolTable<Key, Value> {
    //记录首结点
    private Node head;
    //记录符号表中元素的个数
    private int N;

    private class Node {
        //键
        public Key key;
        //值
        public Value value;
        //下一个结点
        public Node next;

        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }


    }

    public SymbolTable() {
        this.head = new Node(null, null, null);
        this.N = 0;
    }

    /**
     * 获取符号表的个数
     *
     * @return N
     */
    public int size() {
        return N;
    }

    /**
     * 符号表中插入键值对
     *
     * @param key
     * @param value
     */
    public void put(Key key, Value value) {
        Node n = head;
        //如果键已经存在的情况下 就直接替换值
        while (n.next != null) {
            n = n.next;
            if (n.key.equals(key)) {
                n.value = value;
                return;
            }
        }
        //如果不存在 就插入一个键值对
        Node newNode = new Node(key, value, null);
        Node oldNext = head.next;
        newNode.next = oldNext;
        head.next = newNode;
        N++;
    }

    /**
     * 删除符号表的键值对
     *
     * @param key
     */
    public void delete(Key key) {
        Node n = head;
        while (n.next != null) {
            if (n.next.key.equals(key)) {
                n.next = n.next.next;
                N--;
                return;
            }
            //变化n
            n = n.next;
        }
    }


    /**
     * 根据键获得符号表的值
     *
     * @param key
     * @return value
     */
    public Value get(Key key) {
        Node n = head;
        while (n.next != null) {
            n = n.next;
            if (n.key.equals(key)) {
                return n.value;
            }
        }
        return null;
    }
}

```

### 有序符号表实现

刚才实现的符号表，我们可以称之为无序符号表，因为在插入的时候，并没有考虑键值对的顺序，而在实际生活中，有时候我们需要根据键的大小进行排序，插入数据时要考虑顺序，那么接下来我们就实现一下有序符号表

```java
package cn.doudou.algorithm.symbol;

/**
 * Create By 王嘉浩
 * Time 2022-10-23 15:02
 * <p>
 * 有序符号表的设计与实现
 */

public class OrderSymbolTable<Key extends Comparable<Key>, Value> {
    //记录首结点
    private Node head;
    //记录符号表中元素的个数
    private int N;

    private class Node {
        //键
        public Key key;
        //值
        public Value value;
        //下一个结点
        public Node next;

        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public OrderSymbolTable() {
        this.head = new Node(null, null, null);
        this.N = 0;
    }

    /**
     * 获取符号表的个数
     *
     * @return N
     */
    public int size() {
        return N;
    }

    /**
     * 符号表中插入键值对
     *
     * @param key
     * @param value
     */
    public void put(Key key, Value value) {
        //定义两个Node变量，分别记录当前结点和当前结点的上一个结点

        Node curr = head.next;
        Node pre = head;
        while(curr!=null && key.compareTo(curr.key)>0){

            //变换当前结点和前一个结点即可
            pre = curr;
            curr = curr.next;
        }

        //如果当前结点curr的键和要插入的key一样，则替换
        if (curr!=null && key.compareTo(curr.key)==0){
            curr.value = value;
            return;
        }

        //如果当前结点curr的键和要插入的key不一样，把新的结点插入到curr之前
        Node newNode = new Node(key, value, curr);
        pre.next = newNode;

        //元素的个数+1；
        N++;

    }

    /**
     * 删除符号表的键值对
     *
     * @param key
     */
    public void delete(Key key) {
        Node n = head;
        while (n.next != null) {
            if (n.next.key.equals(key)) {
                n.next = n.next.next;
                N--;
                return;
            }
            //变化n
            n = n.next;
        }
    }


    /**
     * 根据键获得符号表的值
     *
     * @param key
     * @return value
     */
    public Value get(Key key) {
        Node n = head;
        while (n.next != null) {
            n = n.next;
            if (n.key.equals(key)) {
                return n.value;
            }
        }
        return null;
    }
}

```

## 二叉树入门

之前我们实现的符号表中，不难看出，符号表的增删查操作，随着元素个数N的增多其耗时也是线性增多的，时间复杂度都是o（n）,为了提高运算效率，接下来我们学习树这种数据结构。

### 树的基本定义

树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家谱、单位的组织架构、等等。
树是由n（n>=1）个有限结点组成一个具有层次关系的集合。把它叫做”树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

![](D:\MD文档笔记\img\算法\树.png)

树具有以下特点：

1.每个结点有零个或多个子结点；
2.没有父结点的结点为根结点；
3.每一个非根结点只有一个父结点；
4.每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树

### 树的相关术语

**结点的度：**

一个结点含有的子树的个数称为该结点的度；

**叶结点：**

度为0的结点称为叶结点，也可以叫做终端结点

**分支结点：**

度不为0的结点称为分支结点，也可以叫做非终端结点

**结点的层次：**

从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推

**结点的层序编号**：

将树中的结点，按照从上层到下层，同层从左到右的次厦排成一个线性序列，把他们编成连续的自然数。

**树的度：**

树中所有结点的度的最大值

**树的高度（深度）：**

树中结点的最大层次

**森林：**

m（m>=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根结点，森林就变成一裸树

![](D:\MD文档笔记\img\算法\森林.png)

**孩子结点：**

一个结点的直接后继结点称为该结点的孩子结点

**双亲结点（父结点）：**

一个结点的直接前驱称为该结点的双亲结点

**兄弟结点：**

同一双亲结点的孩子结点间互称兄弟结点

### 二叉树的基本定义

二叉树就是度不超过2的树（每个结点最多有两个子结点）

![](D:\MD文档笔记\img\算法\树的基本定义.png)

**满二叉树：**

个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。

![](D:\MD文档笔记\img\算法\满二叉树.png)

**完全二叉树：**

叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

![](D:\MD文档笔记\img\算法\完全二叉树.png)

### 二叉查找树的创建

#### 二叉树的结点类

根据对图的观察，我们发现二叉树其实就是由一个一个的结点及其之间的关系组成的，按照面向对象的思想，我们设计一个结点类来描述结点这个事物。

**结点类API设计：**

| 类名     | Node<Key,Value>                                              |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node (Key key,Value value,Node left,Node right)：创建Node对象 |
| 成员变量 | 1.public Nod eleft记录左子结点<br/>2.public Node right记录右子结点<br/>3.public Key key存储键<br/>4.public Value value:存储值 |

**代码实现:**

```java
    private class Node {
        //存储键
        public Key key;
        //存储值
        private Value value;
        //记录左子结点
        public Node left;
        //记录右子结点
        public Node right;

        public Node(Key key, Value value, Node left, Node right) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }
```

#### 二叉查找树API设计

| 类名      | BinaryTree<Key extends Comparable<Key>,Value value>          |
| --------- | ------------------------------------------------------------ |
| 构造方法  | BinaryTree()：创建BinaryTree对象                             |
| 成员变 量 | 1.private Node root:记录根结点<br> 2.private int N:记录树中元素的个数 |
| 成员方 法 | 1. public void put(Key key,Value value):向树中插入一个键值对<br/>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添 加后的新树<br/>3.public Value get(Key key):根据key，从树中找出对应的值 <br/>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br/>5.public void delete(Key key):根据key，删除树中对应的键值对 <br/>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的 新树 7.public int size():获取树中元素的个数 |

#### 二叉查找树实现

**插入方法put实现思想：**

1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用 

2.如果当前树不为空，则从根结点开始： 

​	2.1如果新结点的key小于当前结点的key，则继续找当前结点的左子结点； 

​	2.2如果新结点的key大于当前结点的key，则继续找当前结点的右子结点； 

​	2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。

![](D:\MD文档笔记\img\算法\二叉树插入.png)

**查询方法get实现思想：**
从根节点开始：
	1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；
	2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；
	3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。

**删除方法delete实现思想：**
1.找到被删除结点；
2.找到被删除结点右子树中的最小结点minNode
3.删除右子树中的最小结点
4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树
5.让被删除结点的父节点指向最小结点minNode

![](D:\MD文档笔记\img\算法\数-删除1.png)

![](D:\MD文档笔记\img\算法\树-删除2.png)

![](D:\MD文档笔记\img\算法\树-删除3.png)

