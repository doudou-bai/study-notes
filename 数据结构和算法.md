# 问题数据结构与算法

## 数据结构的分类

### 逻辑性结构分类

逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类，也是我们后面课题中需要关注和讨论的问题。
	a.集合结构：集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系。

​		b.线性结构：线性结构中的数据元素之间存在一对一的关系

​	C.树形结构：树形结构中的数据元素之间存在一对多的层次关系

​	d.图形结构：图形结构的数据元素是多对多的关系

### 物理结构分类：

​	逻辑结构在计算机中真正的表示方式（又称为映像）称为物理结构，也可以叫做存储结构。常见的物理结构有顺序存储结构、链式存储结构。顺序存储结构：
把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的，比如我们常用的数组就是顺序存储结构。

​	顺序存储结构存在一定的弊端，就像生活中排时也会有人插队也可能有人有特殊情况突然离开，这时候整个结构都处于变化中，此时就需要链式存储结构。

#### 链式存储结构：

​	是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置

## 什么是算法

​	算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。

- 算法就是解决特定问题的一系列的执行步骤
- 使用不同的算法,解决同一个问题,效率可能相差非常的大  
- 数据结构是计算机存储、组织数据的方式 

## 数据结构的分类

- 线性结构
  - 线性表
  - 数组
  - 链表
  - 栈
  - 队列
  - 哈希表
- 树形结构
  - 二叉树
  - AVL树
  - 红黑树
  - B树
  - 堆
  - Trie
  - 哈夫曼树
  - 并查集  第一季不讲
- 图形结构
  - 邻接矩阵 第一季不讲
  - 领接表  第一季不讲

## 大O表示法(Big O)

一般用于大O表示法来描述复杂度,它表示的是数据规模n对应的复杂度

注意:大O表示法仅仅是一种粗略的分析模型,是一种估算,能帮助我们短时间内了解一个算法的执行效率

## 时间复杂度

### 常见的复杂度

![](D:\MD文档笔记\img\算法\时间复杂度.PNG)

![](D:\MD文档笔记\img\算法\时间复杂度大小.PNG)

## 斐波那契数列

### 算法一 - 递归

会有算法问题 数字越大计算越慢

```java
public static long fib(long a) {
        if (a <= 1) return a;
        return fib(a - 1) + fib(a - 2);
    }
```

### 算法二 - 循环

```java
public static long fib(long a) {
        if (a <= 1) return a;
        long first = 0;
        long second = 1;
        for (int i = 0; i < a - 1; i++) {
            long sum = first + second;
            second = sum;
            first = second;
        }
        return second;
    }
```

##  线性表

### 简介

线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。

前驱元素：
		若A元素在B元素的前面，则称A为B的前驱元素

后继元素：
		若B元素在A元素的后面，则称B为A的后继元素

**线性表的特征**：数据元素之间具有一种“一对一的逻辑关系。
	1.第一个数据元素没有前驱，这个数据元素被称为头结点；
	2.最后一个数据元素没有后继，这个数据元素被称为尾结点；
	3.除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。

如果把线性表用数学语言来定义，则可以表示为（a1ai-1，aiai+1an），ai-1领先于aiai领先于ai+1，称ai-1是ai的前驱元素，ai+1是ai
的后继元素

### 什么是线性表?

线性表是具有n个相同类型元素的有限序列 (n>=0)

![](D:\MD文档笔记\img\算法\线性表.PNG)

### 数组

**数组是一种顺序存储的线性表,所有元素的内存地址是连续的**

```java
int[] array = new int[] {11,22,33};
```

#### 注:

- 在跟多编程语言中,数组都有个致命的缺点
  - 无法动态修改容量
  - 可能会造成内存空间的大量浪费

## 动态数组的设计

```java
public class ArrayList<E> {
    /*
     * 动态数组的数量
     */
    private int size;
    /*
     * 动态数组的所有元素
     */
    private E[] elements;

    /*
     * 初始化数组的容量
     */
    private static final int DEFAULT_CAPACIIY = 2;

    /*
     * 默认错误的返回值
     */
    private static final int ELEMENT_NOT_FOUND = -1;

    /*
     * 有参数的构造方法
     */
    public ArrayList(int capaticy) {
        // 对数组的初始化的长度进行设置
        capaticy = (capaticy < DEFAULT_CAPACIIY) ? DEFAULT_CAPACIIY : capaticy;
        // 进行对数组的初始化设置
        elements = (E[]) new Object[capaticy];
    }

    /*
     * 无参数的构造发方法
     */
    public ArrayList() {
        // 调用有参数的构造方法进行设置 直接传入默认值
        this(DEFAULT_CAPACIIY);
    }

    /*
     * 清楚所有的元素
     */
    public void clear() {
        for (int i = 0; i < size; i++) {
            elements[i] = null;
        }
        size = 0;
    }

    /*
     * 元素的数量
     * @return
     */
    public int size() {
        return size;
    }

    /*
     * 是否为空
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }


    /*
     * 是否包含某个元素
     * @param element
     * @return
     */
    public boolean contains(E element) {
        return indexOf(element) != ELEMENT_NOT_FOUND;
    }

    /*
     * 根据index进行获取对应位置的元素
     * @param index
     * @return
     */
    public E get(int index) {
        return elements[index];
    }

    /**
     * 设置index位置的元素
     *
     * @param index
     * @param element
     * @return
     */
    public E set(int index, E element) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("数组越界异常！");
        }
        //取出原来的元素进行赋值
        E old = elements[index];
        //对新的元素进行赋值
        elements[index] = element;
        //返回旧的数据
        return old;
    }

    /**
     * 添加到数组的尾部
     *
     * @param element
     */
    public void add(E element) {
        add(size, element);
    }

    /**
     * 在指定位置插入指定的数据
     *
     * @param index
     * @param element
     */
    public void add(int index, E element) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("数组越界异常！");
        }
        ensureCapacity(size + 1);
        for (int i = size; i > index; i--) {
            elements[i] = elements[i - 1];
        }
        elements[index] = element;
        size++;
    }

    /**
     * 查看元素第一次出现的索引
     *
     * @param element
     * @return
     */
    public int indexOf(E element) {
        if (element == null) {
            for (int i = 0; i < size; i++) {
                if (elements[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(elements[i])) {
                    return i;
                }
            }
        }

        return ELEMENT_NOT_FOUND;
    }


    /**
     * 删除数组对应index里面的元素
     *
     * @param index
     * @return
     */
    public E remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("数组越界异常！");
        }
        E old = elements[index];
        for (int i = index + 1; i < size; i++) {
            elements[i - 1] = elements[i];
        }
        size--;
        elements[size] = null;
        return old;
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("ArrayList{ size = ").append(size).append(", elements = [");
        for (int i = 0; i < size; i++) {
            string.append(elements[i]);
            if (i != size - 1) {
                string.append(",");
            }
        }
        string.append("] }");
        return string.toString();
    }

    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;
        int newCapacity = oldCapacity + (oldCapacity << 1);
        E[] newElements = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;
    }
}
```

## 链表

### 单项链表的设计

**链表是一种连式存储的线性表,所有元素的内存地址不一定是连续的**

链表是一种物理存储单元上非连续、非顺序的存储结构，其物理结构不能只管的表示数据元素的逻辑顺序，数据元素的逻辑顺序是通
过链表中的指针链接次序实现的。链表由一系列的结点（链表中的每一个元素称为结点）组成，结点可以在运行时动态生成

#### 接口设计

**链表的大部分接口和动态数组是一致的**

1. List接口
2. LinkedList类
3. 抽象类AbstractList

```java
package cn.doudou;

public interface List<E>{
    /*
     * 默认错误的返回值
     */
    static final int ELEMENT_NOT_FOUND = -1;

    /**
     * 清楚所有的元素
     */
    void clear();

    /**
     * 元素的数量
     * @return
     */
    int size();

    /**
     * 是否为空
     * @return
     */
    boolean isEmpty();

    /**
     * 是否包含某个元素
     * @return
     */
    boolean contains(E element);

    /**
     * 插入元素
     * @param element
     */
    void add(E element);

    /**
     * 获得index位置的元素
     * @param index
     * @return
     */
    E get(int index);

    /**
     * 设置某个位置的元素
     * @param index
     * @param element
     * @return
     */
    E set(int index,E element);

    /**
     * 插入指定位置的元素
     * @param index
     * @param element
     */
    void add(int index,E element);

    /**
     * 删除对应index位置的元素
     * @param index
     * @return
     */
    E remove(int index);

    /**
     * 查看元素第一次出现的位置
     * @param element
     * @return
     */
    int indexOf(E element);
}

```

```java
package cn.doudou;

public class LinkedList<E> extends AbstractList<E> {

    private Node<E> first;

    @Override
    public void clear() {
        size = 0;
        first = null;
    }

    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        if (index == 0) {
            first = new Node<>(element, first);
        } else {
            Node<E> prev = node(index - 1);
            prev.next = new Node<>(element, prev.next);
        }
        size++;
    }

    @Override
    public E remove(int index) {
        rangeCheck(index);
        Node<E> oldNode = first;
        if (index == 0) {
            this.first = this.first.next;
        } else {
            Node<E> node = node(index - 1);
            oldNode = node.next;
            node.next = node.next.next;
        }
        size--;
        return oldNode.element;
    }

    @Override
    public int indexOf(E element) {
        Node<E> node = this.first;
        if (element == null) {
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(node.element)) return i;
                node = node.next;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    /**
     * 内部类
     *
     * @param <E>
     */
    private static class Node<E> {
        E element;
        Node<E> next;

        public Node(E element, Node<E> next) {
            this.element = element;
            this.next = next;
        }
    }

    private Node<E> node(int index) {
        rangeCheck(index);
        Node<E> node = first;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("LinkedList{ size = ").append(size).append(", elements = [");
        Node<E> node = this.first;
        for (int i = 0; i < size; i++) {
            string.append(node.element);
            node = node.next;
            if (i != size - 1) {
                string.append(",");
            }
        }
        string.append("] }");
        return string.toString();
    }
}

```

```java
package cn.doudou;

public abstract class AbstractList <E> implements List<E>{
    protected int size;


    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean contains(E element) {
        return indexOf(element) != ELEMENT_NOT_FOUND;
    }

    public void add(E element) {
        add(size, element);
    }


    /**
     * 检查数组的index是不是越界
     *
     * @param index
     */
    protected void outOfBounds(int index) {
        throw new IndexOutOfBoundsException("数组越界异常!");
    }

    protected void rangeCheck(int index) {
        if (index < 0 || index >= size) {
            outOfBounds(index);
        }
    }

    protected void rangeCheckForAdd(int index) {
        if (index < 0 || index > size) {
            outOfBounds(index);
        }
    }

}

```

#### 虚拟头结点

有时候为了让代码更加的精简,统一所有的节点的处理逻辑,可以在前面加一个虚拟的节点(不存储数据)

```java
package cn.doudou;

/**
 * 虚拟头节点的实现方式
 *
 * @param <E>
 */
public class LinkedList2<E> extends AbstractList<E> {

    private Node<E> first;

    public LinkedList2() {
        first = new Node<>(null, null);
    }

    @Override
    public void clear() {
        size = 0;
        first = null;
    }

    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        Node<E> prev = index == 0 ? first : node(index - 1);
        prev.next = new Node<>(element, prev.next);
        size++;
    }

    @Override
    public E remove(int index) {
        rangeCheck(index);
        Node<E> node = index == 0 ? first : node(index - 1);
        Node<E> oldNode = node.next;
        node.next = node.next.next;

        size--;
        return oldNode.element;
    }

    @Override
    public int indexOf(E element) {
        Node<E> node = this.first;
        if (element == null) {
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(node.element)) return i;
                node = node.next;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    /**
     * 内部类
     *
     * @param <E>
     */
    private static class Node<E> {
        E element;
        Node<E> next;

        public Node(E element, Node<E> next) {
            this.element = element;
            this.next = next;
        }
    }

    private Node<E> node(int index) {
        rangeCheck(index);
        Node<E> node = first.next;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("LinkedList{ size = ").append(size).append(", elements = [");
        Node<E> node = this.first.next;
        for (int i = 0; i < size; i++) {
            string.append(node.element);
            node = node.next;
            if (i != size - 1) {
                string.append(",");
            }
        }
        string.append("] }");
        return string.toString();
    }
}

```

### 双向链表的设计

1. 此前所学的链表,也叫做单项链表
2. 使用双向链表可以提升链表的综合性能

#### 简介



![image-20220511165654283](D:\MD文档笔记\img\算法\双向链表.png)

#### 代码

```java
package cn.doudou;

/**
 * 双向链表的实现
 */
public class LinkedList<E> extends AbstractList<E> {

    /**
     * 指向链表的头结点
     */
    private Node<E> first;
    /**
     * 指向链表的尾节点
     */
    private Node<E> last;

    @Override
    public void clear() {
        size = 0;
        first = null;
        last = null;
    }

    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        if (index == size) {
            Node<E> oldLast = last;
            last = new Node<>(oldLast, element, null);
            //即使第一个元素也是最后一个元素
            if (oldLast == null) {
                first = last;
            } else {
                oldLast.next = last;
            }
        } else {
            //找到需要进行插入的链表
            Node<E> next = node(index);
            //找到上一个链表
            Node<E> prev = next.prev;
            //构建一个Node节点进行插入
            Node node = new Node(prev, element, next);
            /**
             * 我们首先对插入的元素的prev的上一个元素进行相连接的操作
             */
            next.prev = node;
            if (prev == null) {
                first = node;
            } else {
                /**
                 * 我们对元素的下一个元素的上一个指针进行连接的操作
                 */
                prev.next = node;
            }
        }
        /**
         * 最后我们对链表的数量进行加++的操作
         */
        size++;
    }

    @Override
    public E remove(int index) {
        rangeCheck(index);

        Node<E> node = node(index);
        Node<E> next = node.next;
        Node<E> prev = node.prev;

        if (prev == null) { //index == 0
            first = next;
        } else {
            prev.next = next;
        }

        if (next == null) {//index == size-1
            last = prev;
        } else {
            next.prev = prev;
        }
        size--;
        return node.element;
    }

    @Override
    public int indexOf(E element) {
        Node<E> node = this.first;
        if (element == null) {
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(node.element)) return i;
                node = node.next;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    /**
     * 内部类
     *
     * @param <E>
     */
    private static class Node<E> {
        E element;
        Node<E> prev;
        Node<E> next;

        public Node(Node<E> prev, E element, Node<E> next) {
            this.prev = prev;
            this.element = element;
            this.next = next;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();

            if (prev != null) {
                sb.append(prev.element);
            } else {
                sb.append("null");
            }
            sb.append("_").append(element).append("_");

            if (next != null) {
                sb.append(next.element);
            }else {
                sb.append("null");
            }
            return sb.toString();
        }
    }

    private Node<E> node(int index) {
        rangeCheck(index);

        /**
         * 我们这里进行判断
         * 主要实现的思路为
         * 判断index的是否小于size/2的数值 如果是就从左边开始查找,不是的话就从右边开始查找,等于的情况随便都可以
         */
        if (index < (size >> 1)) {
            Node<E> node = first;
            for (int i = 0; i < index; i++) {
                node = node.next;
            }
            return node;
        } else {
            Node<E> node = last;
            for (int i = size - 1; i > index; i--) {
                node = node.prev;
            }
            return node;
        }
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("LinkedList{ size = ").append(size).append(", elements = [");
        Node<E> node = this.first;
        for (int i = 0; i < size; i++) {
            if (i != 0) {
                string.append(",");
            }
            string.append(node);
            node = node.next;
        }
        string.append("]");
        return string.toString();
    }
}

```

### 双向链表VS动态数组

- 动态数组: 开辟、销毁内存空间的次数相对较少,但可能造成内存的空间的浪费(可以通过缩容进行解决)
- 双向链表：开辟、销毁内存空间的此次数相对较多,但不会造成内存空间的浪费

1. 如果频繁在尾部进行添加 删除操作 动态数组 双向链表均可选择
2. 如果频繁在头部进行添加 删除操作 建议选择使用双向链表
3. 如果有频繁的在任意位置 添加 删除操作 建议选择使用双向链表
4. 如果有频繁的查询操作随机访问操作 建议选择使用动态数组

### 链表的复杂度分析

get（inti:每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素N的增多，比较的元素越多，时间复杂度为O（n）
insert（inti.Tt:每一次插入，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂
度为O（n）；
remove（inti:每一次移除，需要先找到位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂
度为O（n）
相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的，它不需要预先指定
存储空间大小，或者在存储过程中涉及到扩容等操作，同时它并没有涉及的元素的交换。
相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议
使用链表。

### 链表反转

单链表的反转，是面试中的一个高频题目。

**需求**：
		原链表中数据为：1->2->3>4
		反转后链表中数据为：4->3->2->1
**反转API：**

`public void reverse（）：对整个链表反转`

`public Node reverse（Nodecurr）：反转链表中的某个结点curr，并把反转后的curr结点返回`

使用递归可以完成反转，递归反转其实就是从原链表的第一个存数据的结点开始，依次递归调用反转每一个结点，直到把最后一个结
点反转完毕，整个链表就反转完毕。

##### 代码

```java
 //用来反转整个链表
    public void reverse() {
        //判断链表是否为空
        if (isEmpty()) {
            return;
        }
        reverse(head.next);
    }

    //反转指定的结点curr，并把反转后的结点返回
    public Node reverse(Node curr) {
        if (curr.next == null) {
            //头部结点的下一个节点等于curr
            head.next = curr;
            return curr;
        }
        Node pre = reverse(curr.next);
        pre.next = curr;
        curr.next = null;
        return curr ;
    }
```

### 快慢指针

#### 中间值问题

**代码**

```java
    /**
     * @param first 链表的首结点
     * @return 链表的中间结点的值
     */
    public static String getMid(Node<String> first) {
        //定义两个指针
        Node fast = first;
        Node slow = first;
        //当快指针指向的节点没有下一个节点了就结束了 返回慢指针的值
        while (fast != null && fast.next != null) {
            //变换fast和slow的节点
            fast = fast.next.next;
            slow = slow.next;
        }
        return (String) slow.item;
    }
```

#### 单项链表是否有环

**代码**

```java
/**
     * 判断链表中是否有环
     * @param first 链表首结点
     * @return ture为有环，false为无环
     */
    public static boolean isCircle(Node<String> first) {
        //定义快慢指针
        Node<String> fast = first;
        Node<String> slow = first;

        //遍历链表，如果快慢指针指向了同一个结点，那么证明有环
        while(fast!=null && fast.next!=null){
            //变换fast和slow
            fast = fast.next.next;
            slow = slow.next;

            if (fast.equals(slow)){
                return true;
            }
        }

        return false;
    }
```

#### 有环链表入口

**代码**

```java
/**
     * 查找有环链表中环的入口结点
     *
     * @param first 链表首结点
     * @return 环的入口结点
     */
    public static Node getEntrance(Node<String> first) {
        //定义快慢指针
        Node<String> fast = first;
        Node<String> slow = first;
        Node<String> temp = null;

        //遍历链表，先找到环(快慢指针相遇),准备一个临时指针，指向链表的首结点，继续遍历，直到慢指针和临时指针相遇，那么相遇时所指向的结点就是环的入口
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;

            if (fast.equals(slow)) {
                temp = first;
                continue;
            }
            //让临时节点变换
            if (temp != null) {
                temp = temp.next;
                //判断临时指针是否和慢指针相遇
                if (temp.equals(slow)) {
                    break;
                }
            }
        }
        return temp;
    }
```

### 循环链表

循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结点，因为没有下一个元
素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。

![](D:\MD文档笔记\img\算法\环形链表.png)

**代码**

```java
public static void main(String[] args) throws Exception {
        Node<String> first = new Node<String>("aa", null);
        Node<String> second = new Node<String>("bb", null);
        Node<String> third = new Node<String>("cc", null);
        Node<String> fourth = new Node<String>("dd", null);
        Node<String> fifth = new Node<String>("ee", null);
        Node<String> six = new Node<String>("ff", null);
        Node<String> seven = new Node<String>("gg", null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
        //构建循环链表，让最后一个结点指向第一个结点

        seven.next = first;
    }
```

### 约瑟夫问题

**问题描述：**

传说有这样一个故事，在罗马人占领乔塔帕特后，39个犹太人与约瑟夫及他的朋友熟到一个洞中，39个犹太人决定宁愿死也不要被敌
人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次往后，如果有人报数到3，那么这个人就必须
自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡为止。然而约琴夫和他的朋友并不想遵从。于是，约瑟夫要他
的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，从而逃过了这场死亡游戏。

**问题转换：**

41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。
1.编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈；
2.自退出那个人开始的下一个人再次从1开始报数，以此类推；
3.求出最后退出的那个人的编号

```java
 public static void main(String[] args) {
        //约瑟夫问题
        //构建循环链表
        //存储首个节点
        Node<Integer> first = null;
        //存储记录的前一个节点
        Node<Integer> pre = null;
        for (int i = 1; i <= 41; i++) {
            //如果是首节点
            if (i == 1) {
                first = new Node<>(i, null);
                pre = first;
                continue;
            }
            //如果不是首节点
            Node<Integer> newNode = new Node<>(i, null);
            pre.next = newNode;
            pre = newNode;
            //如果是尾节点
            if (i == 41) {
                pre.next = first;
            }
        }
        //需要count计数器 模拟报数
        int count = 0;
        //遍历循环列表
        //记录每次拿到的节点 默认从首节点开始
        Node<Integer> n = first;
        //记录当前节点的上一个节点
        Node<Integer> before = null;
        while (n != n.next) {
            //模拟报数
            count++;
            //判断当前报数是不是3
            if (count == 3) {
                //如果是3就删除节点并打印节点 重置计数器 让当前节点进行后移
                before.next = n.next;
                System.out.print(n.item + ",");
                count = 0;
                n = n.next;
            } else {
                //如果不是3就让当前节点后移 让before变成当前节点
                before = n;
                n = n.next;
            }
        }
        System.out.println(n.item);
    }
```

## 栈

栈是一种特殊的线性表，只能在一端进行操作
往栈中添加元素的操作，一般叫做push，入栈
从栈中移除元素的操作，一般叫做pop，出栈（只能移除栈顶元素，也叫做：弹出栈顶元素）
后进先出的原则，LastInFirstOut，LIFO

### 生活中的栈

存储货物或供旅客住宿的地方，可引申为仓库、中转站。例如我们现在生活中的酒店，在古时候叫客栈，是供旅客休息的地方，旅客可以进客栈休息，休息完毕后就离开客栈

### 计算机中的栈

我们把生活中的栈的概念引入到计算机中，就是供数据休息的地方，它是一种数据结构，数据既可以进入到栈中，又可以从栈中出
去。
栈是一种基于先进后出（FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先
进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。

我们称数据进入到栈的动作为**压栈**，数据从栈中出去的动作为**弹栈**

![](D:\MD文档笔记\img\算法\栈.png)

### 栈API的设计与实现

| 类名       | Stack<T>                                                     |
| ---------- | ------------------------------------------------------------ |
| 构造方法   | Stack)：创建Stack对象                                        |
| 成员方法   | 1.public boolean isEmpy()：判断栈是否为空，是返回wrue，否返回false<br/>2.public int size(): 获取栈中元素的个数<br/>3.public T pop(): 弹出栈顶元素<br/>4.public void push(T t）：向栈中压入元素t |
| 成员变量   | 1.private Node head:记录首结点<br/>2.private int N:当前栈的元素个数 |
| 成员内部类 | private class Node：节点类                                   |

### 栈代码实现

```java
package cn.doudou.algorithm.linear;

import javax.xml.soap.Node;
import java.util.Iterator;

/**
 * Create By 王嘉浩
 * Time 2022-09-20 16:59
 * 栈的实现
 */
public class Stack<T> implements Iterable<T> {
    //记录首节点
    private Node head;
    //栈中元素的个数
    private int N;


    /**
     * Node的节点内部类
     */
    private class Node {
        public T item;
        public Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    /**
     * 初始化栈内部的元素
     */
    public Stack() {
        this.head = new Node(null, null);
        this.N = 0;
    }

    /**
     * 判断栈中元素的个数是不是为0
     *
     * @return boolean
     */
    public boolean isEmpty() {
        return N == 0;
    }

    /**
     * 获取栈中元素的个数
     *
     * @return int
     */
    public int size() {
        return N;
    }

    /**
     * 把元素t压入栈中
     *
     * @param t
     */
    public void push(T t) {
        //找到首节点指向的第一个节点
        Node oldFirst = head.next;
        //创建新的节点
        Node newNode = new Node(t, null);
        //让首节点指向新的节点
        head.next = newNode;
        //让新的节点指向原来第一个节点
        newNode.next = oldFirst;
        //元素个数+1
        N++;
    }

    /**
     * 弹出定栈元素
     *
     * @return T
     */
    public T pop() {
        //找到首节点指向的第一个节点
        Node oldFirst = head.next;
        if (oldFirst == null) {
            return null;
        }
        //修改head的next的指向
        head.next = oldFirst.next;
        //元素个数-1
        N--;
        //弹出元素
        return oldFirst.item;
    }


    @Override
    public Iterator<T> iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator {
        private Stack.Node n;

        public SIterator() {
            this.n = head;
        }

        @Override
        public boolean hasNext() {
            return n.next != null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}
```

### 括号匹配问题

**问题描述:**

```
给定一个字符串，里边可能包含“（）“小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。
例如：
“（上海）（长安）”：正确匹配
“上海（（长安））”：正确匹配
“上海（长安（北京）（深圳）南京）”：正确匹配
“上海（长安））”：错误匹配
“（（上海）长安”：错误匹配
```

代码:



```java
package cn.doudou.algorithm.test;

import cn.doudou.algorithm.linear.Stack;

/**
 * Create By 王嘉浩
 * Time 2022-10-18 10:38
 */
public class BracketsMatchTest {
    public static void main(String[] args) {
        String str = "(上海(长安))";
        boolean match = isMatch(str);
        System.out.println(match);
    }

    private static boolean isMatch(String str) {
        //1.创建栈对象
        Stack<String> chars = new Stack<>();
        //2.循环遍历字符串的每个字符
        for (int i = 0; i < str.length(); i++) {
            String currChar = str.charAt(i) + "";
            //3.判断字符是不是等于左侧括号是的话就向栈里面进行添加一个左括号
            if (currChar.equals("(")) {
                chars.push(currChar);
            }
            //4.判断是不是右括号是的话就弹出一个左括号
            if (currChar.equals(")")) {
                String pop = chars.pop();
                //5.判断弹出的元素是否成功
                if (pop == null) {
                    return false;
                }
            }
        }
        //6.判断栈中是否还有左括号,如果有,证明不匹配.没有则匹配
        if (chars.size() == 0) {
            return true;
        } else {
            return false;
        }
    }
}

```

### 逆波兰表达式求值

逆波兰表达式求值问题是我们计算机中经常遇到的一类问题，要研究明白这个问题，首先我们得搞清楚什么是逆波兰表达式？要搞清楚逆波兰表达式，我们得从中缀表达式说起。
**中缀表达式：**
中缀表达式就是我们平常生活中使用的表达式，例如：1+3*2.2-（1+3）等等，中缀表达式的特点是：二元运算符总是置于两个操作数中间。
中经表达式是人们最喜欢的表达式方式，因为简单，易懂。但是对于计算机来说就不是这样了，因为中缀表达式的运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中表达式，需要解析表达式语义，做大量的优先级相关操作。
**逆波兰表达式（后缓表达式）：**
逆波兰表达式是波兰逻辑学家]·卢卡西维兹（·Lukasewicz）于1929年首先提出的一种表达式的表示方法，后缀表达式的特点：运算符总是放在跟它相关的操作数之后。

| 中缀表达式 | 逆波兰表达式 |
| :--------: | :----------: |
|    a+b     |     ab+      |
|  a+(b-c)   |    abc-+     |
| a+(b-c)*d  |   abc-d*+    |
| a*(b-c)+d  |   abc-*d+    |

#### 代码:

```java
package cn.doudou.algorithm.test;

import cn.doudou.algorithm.linear.Stack;

/**
 * Create By 王嘉浩
 * Time 2022-10-18 10:38
 */
public class BracketsMatchTest {
    public static void main(String[] args) {
        String str = "(上海(长安))";
        boolean match = isMatch(str);
        System.out.println(match);
    }

    private static boolean isMatch(String str) {
        //1.创建栈对象
        Stack<String> chars = new Stack<>();
        //2.循环遍历字符串的每个字符
        for (int i = 0; i < str.length(); i++) {
            String currChar = str.charAt(i) + "";
            //3.判断字符是不是等于左侧括号是的话就向栈里面进行添加一个左括号
            if (currChar.equals("(")) {
                chars.push(currChar);
            }
            //4.判断是不是右括号是的话就弹出一个左括号
            if (currChar.equals(")")) {
                String pop = chars.pop();
                //5.判断弹出的元素是否成功
                if (pop == null) {
                    return false;
                }
            }
        }
        //6.判断栈中是否还有左括号,如果有,证明不匹配.没有则匹配
        if (chars.size() == 0) {
            return true;
        } else {
            return false;
        }
    }
}

```

## 队列

队列是一种基于先进先出（FIFO）的数据结构，是一种只能在一端进行插入在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。

![](D:\MD文档笔记\img\算法\队列介绍.png)

### 队列的API设计

| 类名       | Queue<T>                                                     |
| ---------- | ------------------------------------------------------------ |
| 构造方法   | Queue(）：创建Queue对象                                      |
| 成员方法   | 1.public booleanisEmpty()：判断队列是否为空，是返回true，否返回false<br/>2.public intsize()获取队列中元素的个数<br/>3.public Tdequeue():从队列中拿出一个元素<br/>4.public void engueue(T t）：往队列中插入一个元素 |
| 成员变量   | 1.private Node head:头部结点<<br/>2.private int N:当前栈的元素个数<br/>3.private Node last记录最后一个结点 |
| 成员内部类 | private class Node结点类                                     |

### 代码

```java
package cn.doudou.algorithm.linear;

import java.util.Iterator;

public class Queue<T> implements Iterable<T> {
    //记录首结点
    private Node head;
    //记录最后一个结点
    private Node last;
    //记录队列中元素的个数
    private int N;


    private class Node {
        public T item;
        public Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    public Queue() {
        this.head = new Node(null, null);
        this.last = null;
        this.N = 0;
    }

    //判断队列是否为空
    public boolean isEmpty() {
        return N == 0;
    }

    //返回队列中元素的个数
    public int size() {
        return N;
    }

    //向队列中插入元素t
    public void enqueue(T t) {
        if (last == null) {
            //last为null
            last = new Node(t, null);
            head.next = last;
        } else {
            //last不为null
            Node oldLast = last;
            last = new Node(t, null);
            oldLast.next = last;
        }
        N++;
    }

    //从队列中拿出一个元素
    public T dequeue() {
        if (isEmpty()) {
            return null;
        }
        Node oldNode = head.next;
        head.next = oldNode.next;
        N--;
        if (isEmpty()) {
            last = null;
        }
        return oldNode.item;
    }


    @Override
    public Iterator<T> iterator() {
        return new QIterator();
    }

    private class QIterator implements Iterator {
        private Node n;

        public QIterator() {
            this.n = head;
        }

        @Override
        public boolean hasNext() {
            return n.next != null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}
```

## 双端队列(Deque)

- 双端队列是能在头尾两端添加、删除的队列
- 英文deque是double ended queue的简称

![](D:\MD文档笔记\img\算法\双端队列.png)



| 类名     | Deque<E>                                                     |
| -------- | ------------------------------------------------------------ |
| 构造方法 |                                                              |
| 方法     | int size(); 元素的数量 <br/>boolean isEmpty() 是否为空<br/>void enQueueRear(E element) 从队尾入队<br/>void enQueueFront(E element) 从队头入队 <br/>E deQueueRear() 从队尾出队 <br/>E front()获取队列的头元素 <br/>E rear() 获取队列的尾元素<br> |

### 代码实现

```java
public class Deque<E> {
    private List<E> list = new LinkedList<>();

    public int size() {
        return list.size();
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    public void enQueueRear(E element) {
        list.add(element);
    }

    public E enQueueFront() {
        return list.remove(0);
    }

    public void enQueueFront(E element) {
        list.add(0, element);
    }

    public E deQueueRear() {
        return list.remove(list.size() - 1);
    }

    public E front() {
        return list.get(0);
    }

    public E rear() {
        return list.get(list.size() - 1);
    }

}
```

## 循环队列(Circle Queue)

- 循环双端队列：可以进行两端添加、删除操作的循环队列

- 盾环队列底层用数组实现

### 代码

```java
public class CircleQueue<E> {
    /**
     * 头部索引
     */
    private int front;
    /**
     * 数量
     */
    private int size;
    /**
     * 使用动态数组进行实现 默认为10
     */
    private E[] elements;

    /**
     * 默认的容量
     */
    private static final int DEFAULT_CAPACIIY = 10;

    public CircleQueue() {
        elements = (E[]) new Object[DEFAULT_CAPACIIY];
    }

    /**
     * 返回双向队列的个数
     *
     * @return
     */
    public int size() {
        return size;
    }

    /**
     * 判断是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 入队
     *
     * @param element
     */
    public void enQueue(E element) {
        ensureCapacity(size + 1);
        //计算下要入队的元素的索引值在哪里
        int i = index(size);
        elements[i] = element;
        size++;
    }

    /**
     * 出队
     *
     * @return
     */
    public E deQueue() {
        //取出元素
        E frontElement = elements[front];
        //原来位置的元素设置为空
        elements[front] = null;
        //调整front的指向
        front = index(1);
        //数组个数--
        size--;
        return frontElement;
    }

    /**
     * 返回第一个头部元素
     *
     * @return
     */
    public E front() {
        return elements[front];
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("CircleQueue{ size = ").append(size)
                .append(" length = ").append(elements.length)
                .append(", elements = [");
        for (int i = 0; i < size; i++) {
            string.append(elements[i]);
            if (i != size - 1) {
                string.append(",");
            }
        }
        string.append("] }");
        return string.toString();
    }

    /**
     * 动态扩容
     *
     * @param capacity
     */
    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;

        int newCapacity = oldCapacity + (oldCapacity >> 1);
        E[] newElements = (E[]) new Object[newCapacity];

        for (int i = 0; i < size; i++) {
            newElements[i] = elements[index(i)];
        }
        elements = newElements;
        //重置front指向为0
        front = 0;
    }

    /**
     * 封装索引
     *
     * @param i
     * @return
     */
    private int index(int i) {
        return (front + i) % elements.length;
    }
}
```

## 循环双端队列

循环双端队列：可以进行两端添加、删除操作的循环队列

```java
public class CircleDeque<E> {
    /**
     * 头部索引
     */
    private int front;
    /**
     * 数量
     */
    private int size;
    /**
     * 使用动态数组进行实现 默认为10
     */
    private E[] elements;

    /**
     * 默认的容量
     */
    private static final int DEFAULT_CAPACIIY = 10;

    public CircleDeque() {
        elements = (E[]) new Object[DEFAULT_CAPACIIY];
    }

    /**
     * 返回双向队列的个数
     *
     * @return
     */
    public int size() {
        return size;
    }

    /**
     * 判断是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 从尾部入队
     *
     * @param element
     */
    public void enQueueRear(E element) {
        ensureCapacity(size + 1);
        //计算下要入队的元素的索引值在哪里
        elements[index(size)] = element;
        size++;
    }

    /**
     * 从头部入队
     *
     * @param element
     */
    public void enQueueFront(E element) {
        ensureCapacity(size + 1);
        front = index(-1);
        elements[front] = element;
        size++;
    }

    /**
     * 从尾部出队
     */
    public E deQueueFrRear() {
        int rearIndex = index(size - 1);
        E element = elements[rearIndex];
        elements[rearIndex] = null;
        size--;
        return element;
    }

    /**
     * 从头部出队
     */
    public E deQueueFront() {
        //取出元素
        E frontElement = elements[front];
        //原来位置的元素设置为空
        elements[front] = null;
        //调整front的指向
        front = index(1);
        //数组个数--
        size--;
        return frontElement;
    }


    /**
     * 获取头部的元素
     *
     * @return
     */
    public E front() {
        return elements[front];
    }

    /**
     * 获取尾部的元素
     *
     * @return
     */
    public E Rear() {
        return elements[index(size - 1)];
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("CircleQueue{ size = ").append(size)
                .append(" length = ").append(elements.length)
                .append(", elements = [");
        for (int i = 0; i < elements.length; i++) {
            string.append(elements[i]);
            if (i != elements.length - 1) {
                string.append(",");
            }
        }
        string.append("] }");
        return string.toString();
    }

    /**
     * 动态扩容
     *
     * @param capacity
     */
    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;

        int newCapacity = oldCapacity + (oldCapacity >> 1);
        E[] newElements = (E[]) new Object[newCapacity];

        for (int i = 0; i < size; i++) {
            newElements[i] = elements[index(i)];
        }
        elements = newElements;
        //重置front指向为0
        front = 0;
    }

    /**
     * 封装索引
     *
     * @param i
     * @return
     */
    private int index(int i) {
        i += front;
        //需要判断下如果是负数的情况下就加上elements.length
        if (i < 0) {
            return i + elements.length;
        }
        return i - (i >= elements.length ? elements.length : 0);

    }
}
```



## 符号表

符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值。

![](D:\MD文档笔记\img\算法\符号表.png)

符号表中，键具有唯一性。
符号表在实际生活中的使用场景是非常广泛的，见下表:

| 应用     | 查找目的                 | 键     | 值       |
| -------- | ------------------------ | ------ | -------- |
| 字典     | 找出单词的释义           | 单词   | 释义     |
| 图书索引 | 找出某个术语相关的页码   | 术语   | 一串页码 |
| 网络搜索 | 找出某个关键字对应的网页 | 关键字 | 网页名称 |

### 符号表API设计

**节点类:**

| 类名     | Node<Key,Value>                                              |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(Key key.Value value,Node next）：创建Node对象           |
| 成员变量 | 1.public Key key存储键<br/>2.public value value存储值<br/>3.public Node next存储下一个结点 |

**符号表:**

| 类名     | SymbolTabl<Key,Value>                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | SymbolTable()：创建SymbolTable对象                           |
| 成员方法 | 1.public Value get(key key)：根据键key，找对应的值<br/>2public void put(Key key,Value val):向符号表中插入一个键值对<br/>3.public void delete(Key key)删除键为key的键值对<br/>4.public int size()：获取符号表的大小 |
| 成员变量 | 1.private Node head:记录首结点 <br/>2.private int N:记录符号表中键值对的个数 |

### 符号表实现

```java
package cn.doudou.algorithm.symbol;

/**
 * Create By 王嘉浩
 * Time 2022-10-23 15:02
 * <p>
 * 符号表的设计与实现
 */

public class SymbolTable<Key, Value> {
    //记录首结点
    private Node head;
    //记录符号表中元素的个数
    private int N;

    private class Node {
        //键
        public Key key;
        //值
        public Value value;
        //下一个结点
        public Node next;

        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }


    }

    public SymbolTable() {
        this.head = new Node(null, null, null);
        this.N = 0;
    }

    /**
     * 获取符号表的个数
     *
     * @return N
     */
    public int size() {
        return N;
    }

    /**
     * 符号表中插入键值对
     *
     * @param key
     * @param value
     */
    public void put(Key key, Value value) {
        Node n = head;
        //如果键已经存在的情况下 就直接替换值
        while (n.next != null) {
            n = n.next;
            if (n.key.equals(key)) {
                n.value = value;
                return;
            }
        }
        //如果不存在 就插入一个键值对
        Node newNode = new Node(key, value, null);
        Node oldNext = head.next;
        newNode.next = oldNext;
        head.next = newNode;
        N++;
    }

    /**
     * 删除符号表的键值对
     *
     * @param key
     */
    public void delete(Key key) {
        Node n = head;
        while (n.next != null) {
            if (n.next.key.equals(key)) {
                n.next = n.next.next;
                N--;
                return;
            }
            //变化n
            n = n.next;
        }
    }


    /**
     * 根据键获得符号表的值
     *
     * @param key
     * @return value
     */
    public Value get(Key key) {
        Node n = head;
        while (n.next != null) {
            n = n.next;
            if (n.key.equals(key)) {
                return n.value;
            }
        }
        return null;
    }
}

```

### 有序符号表实现

刚才实现的符号表，我们可以称之为无序符号表，因为在插入的时候，并没有考虑键值对的顺序，而在实际生活中，有时候我们需要根据键的大小进行排序，插入数据时要考虑顺序，那么接下来我们就实现一下有序符号表

```java
package cn.doudou.algorithm.symbol;

/**
 * Create By 王嘉浩
 * Time 2022-10-23 15:02
 * <p>
 * 有序符号表的设计与实现
 */

public class OrderSymbolTable<Key extends Comparable<Key>, Value> {
    //记录首结点
    private Node head;
    //记录符号表中元素的个数
    private int N;

    private class Node {
        //键
        public Key key;
        //值
        public Value value;
        //下一个结点
        public Node next;

        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public OrderSymbolTable() {
        this.head = new Node(null, null, null);
        this.N = 0;
    }

    /**
     * 获取符号表的个数
     *
     * @return N
     */
    public int size() {
        return N;
    }

    /**
     * 符号表中插入键值对
     *
     * @param key
     * @param value
     */
    public void put(Key key, Value value) {
        //定义两个Node变量，分别记录当前结点和当前结点的上一个结点

        Node curr = head.next;
        Node pre = head;
        while(curr!=null && key.compareTo(curr.key)>0){

            //变换当前结点和前一个结点即可
            pre = curr;
            curr = curr.next;
        }

        //如果当前结点curr的键和要插入的key一样，则替换
        if (curr!=null && key.compareTo(curr.key)==0){
            curr.value = value;
            return;
        }

        //如果当前结点curr的键和要插入的key不一样，把新的结点插入到curr之前
        Node newNode = new Node(key, value, curr);
        pre.next = newNode;

        //元素的个数+1；
        N++;

    }

    /**
     * 删除符号表的键值对
     *
     * @param key
     */
    public void delete(Key key) {
        Node n = head;
        while (n.next != null) {
            if (n.next.key.equals(key)) {
                n.next = n.next.next;
                N--;
                return;
            }
            //变化n
            n = n.next;
        }
    }


    /**
     * 根据键获得符号表的值
     *
     * @param key
     * @return value
     */
    public Value get(Key key) {
        Node n = head;
        while (n.next != null) {
            n = n.next;
            if (n.key.equals(key)) {
                return n.value;
            }
        }
        return null;
    }
}

```

## 二叉树入门<Binary Tree>

之前我们实现的符号表中，不难看出，符号表的增删查操作，随着元素个数N的增多其耗时也是线性增多的，时间复杂度都是o（n）,为了提高运算效率，接下来我们学习树这种数据结构。

### 树的基本定义

树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家谱、单位的组织架构、等等。
树是由n（n>=1）个有限结点组成一个具有层次关系的集合。把它叫做”树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

![](D:\MD文档笔记\img\算法\树.png)

树具有以下特点：

1.每个结点有零个或多个子结点；
2.没有父结点的结点为根结点；
3.每一个非根结点只有一个父结点；
4.每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树

### 树的相关术语

**结点的度：**

一个结点含有的子树的个数称为该结点的度；

**叶结点：**

度为0的结点称为叶结点，也可以叫做终端结点

**分支结点：**

度不为0的结点称为分支结点，也可以叫做非终端结点

**结点的层次：**

从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推

**结点的层序编号**：

将树中的结点，按照从上层到下层，同层从左到右的次厦排成一个线性序列，把他们编成连续的自然数。

**树的度：**

树中所有结点的度的最大值

**树的高度（深度）：**

树中结点的最大层次

**森林：**

m（m>=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根结点，森林就变成一裸树

![](D:\MD文档笔记\img\算法\森林.png)

**孩子结点：**

一个结点的直接后继结点称为该结点的孩子结点

**双亲结点（父结点）：**

一个结点的直接前驱称为该结点的双亲结点

**兄弟结点：**

同一双亲结点的孩子结点间互称兄弟结点

### 二叉树的基本定义

二叉树就是度不超过2的树（每个结点最多有两个子结点）

![](D:\MD文档笔记\img\算法\树的基本定义.png)

**满二叉树：**

个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。

![](D:\MD文档笔记\img\算法\满二叉树.png)

**完全二叉树：**

叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

![](D:\MD文档笔记\img\算法\完全二叉树.png)

### 二叉查找树的创建

#### 二叉树的结点类

根据对图的观察，我们发现二叉树其实就是由一个一个的结点及其之间的关系组成的，按照面向对象的思想，我们设计一个结点类来描述结点这个事物。

**结点类API设计：**

| 类名     | Node<Key,Value>                                              |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node (Key key,Value value,Node left,Node right)：创建Node对象 |
| 成员变量 | 1.public Nod eleft记录左子结点<br/>2.public Node right记录右子结点<br/>3.public Key key存储键<br/>4.public Value value:存储值 |

**代码实现:**

```java
    private class Node {
        //存储键
        public Key key;
        //存储值
        private Value value;
        //记录左子结点
        public Node left;
        //记录右子结点
        public Node right;

        public Node(Key key, Value value, Node left, Node right) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }
```

#### 二叉查找树API设计

| 类名      | BinaryTree<Key extends Comparable<Key>,Value value>          |
| --------- | ------------------------------------------------------------ |
| 构造方法  | BinaryTree()：创建BinaryTree对象                             |
| 成员变 量 | 1.private Node root:记录根结点<br> 2.private int N:记录树中元素的个数 |
| 成员方 法 | 1. public void put(Key key,Value value):向树中插入一个键值对<br/>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添 加后的新树<br/>3.public Value get(Key key):根据key，从树中找出对应的值 <br/>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br/>5.public void delete(Key key):根据key，删除树中对应的键值对 <br/>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的 新树 7.public int size():获取树中元素的个数 |

#### 二叉查找树实现

**插入方法put实现思想：**

1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用 

2.如果当前树不为空，则从根结点开始： 

​	2.1如果新结点的key小于当前结点的key，则继续找当前结点的左子结点； 

​	2.2如果新结点的key大于当前结点的key，则继续找当前结点的右子结点； 

​	2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。

![](D:\MD文档笔记\img\算法\二叉树插入.png)

**查询方法get实现思想：**
从根节点开始：
	1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；
	2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；
	3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。

**删除方法delete实现思想：**
1.找到被删除结点；
2.找到被删除结点右子树中的最小结点minNode
3.删除右子树中的最小结点
4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树
5.让被删除结点的父节点指向最小结点minNode

![](D:\MD文档笔记\img\算法\数-删除1.png)

![](D:\MD文档笔记\img\算法\树-删除2.png)

![](D:\MD文档笔记\img\算法\树-删除3.png)

### 查找二叉树中最小的键

| public Key min()         | 找出树中最小的键               |
| ------------------------ | ------------------------------ |
| private Node min(Node x) | 找出指定树X中,最小键所在的节点 |

**代码实现**

```java
 /**
     * 找出树中最小的键
     *
     * @return
     */
    public Key min() {
        return min(root).key;
    }

    /**
     * 找出指定树X中,最小键所在的节点
     *
     * @param x
     * @return
     */
    public Node min(Node x) {
        if (x.left != null) {
            return min(x.left);
        } else {
            return x;
        }
    }
```

### 查找二叉树中最大的键

| public Key max()         | 找出树中最大的键               |
| ------------------------ | ------------------------------ |
| private Node max(Node x) | 找出指定树X中,最大键所在的节点 |

**代码实现**

```java
/**
     * 找出树中最大的键
     *
     * @return
     */
    public Key max() {
        return max(root).key;
    }

    /**
     * 找出指定树X中,最大键所在的节点
     *
     * @param x
     * @return
     */
    public Node max(Node x) {
        if (x.right != null) {
            return max(x.right);
        } else {
            return x;
        }
    }
```

### 二叉树的基础遍历

很多情况下，我们可能需要像遍历数组数组一样，遍历树，从而拿出树中存储的每一个元素，由于树状结构和线性结构不一样，它没
有办法从头开始依次向后遍历，所以存在如何遍历，也就是按照什么样的搜索路径进行遍历的问题。

![](D:\MD文档笔记\img\算法\二叉树遍历.png)

我们把树简单的画作上图中的样子，由一个根节点、一个左子树、一个右子树组成，那么按照根节点什么时候被访问，我们可以把
叉树的遍历分为以下三种方式

1.前序遍历；

​	先访问根结点，然后再访问左子树，最后访问右子树

2.中序遍历：

​	先访问左子树，中间访问根节点，最后访问右子树

3.后序遍历：

​	先访问左子树，再访问右子树，最后访问根节点

### 前序遍历

添加前序遍历的API

`public Queue preErgodic()：使用前序遍历，获取整个树中的所有键 `

`private void preErgodic(Node x,Queue keys)：使用前序遍历，把指定树x中的所有键放入到keys队列中 实现过程中，我们通过前序遍历，把,把每个结点的键取出，放入到队列中返回即可。`

**实现步骤：**

1.把当前结点的key放入到队列中; 

2.找到当前结点的左子树，如果不为空，递归遍历左子树 

3.找到当前结点的右子树，如果不为空，递归遍历右子树

**代码:**

```java
/**
     * 使用前序遍历，获取整个树中的所有键
     *
     * @return
     */
    public Queue preErgodic() {
        Queue<Key> keys = new Queue<>();
        preErgodic(root, keys);
        return keys;
    }

    /**
     * 使用前序遍历，把指定树x中的所有键放入到keys队列中
     *
     * @param x
     * @param keys
     */
    private void preErgodic(Node x, Queue keys) {
        //判断x是否为空
        if (x == null) {
            return;
        }
        keys.enqueue(x.key);

        if (x.left != null) {
            preErgodic(x.left, keys);
        }
        if (x.right != null) {
            preErgodic(x.right, keys);
        }
    }
```

### 中序遍历

`public Queue midErgodic()：使用中序遍历，获取整个树中的所有键 `

`private void midErgodic(Node x,Queue keys)：使用中序遍历，把指定树x中的所有键放入到keys队列中`

实现步骤： 

1.找到当前结点的左子树，如果不为空，递归遍历左子树 

2.把当前结点的key放入到队列中; 

3.找到当前结点的右子树，如果不为空，递归遍历右子树

**代码:**

```java
public Queue midErgodic() {
        Queue<Key> keys = new Queue<>();
        preErgodic(root, keys);
        return keys;
    }

    public void midErgodic(Node x, Queue keys) {
        //判断x是否为空
        if (x == null) {
            return;
        }

        //递归遍历左节点
        if (x.left != null) {
            preErgodic(x.left, keys);
        }

        keys.enqueue(x.key);

        if (x.right != null) {
            preErgodic(x.right, keys);
        }
    }
```

### 后序遍历

`public Queue afterErgodic()：使用后序遍历，获取整个树中的所有键`

`public Queue afterErgodic()：使用后序遍历，获取整个树中的所有键`

实现步骤： 

1.找到当前结点的左子树，如果不为空，递归遍历左子树 

2.找到当前结点的右子树，如果不为空，递归遍历右子树 

3.把当前结点的key放入到队列中

**代码：**

```java
/**
     * 使用后序遍历，获取整个树中的所有键
     *
     * @return
     */
    public Queue afterErgodic() {
        Queue<Key> keys = new Queue<>();
        afterErgodic(root, keys);
        return keys;
    }

    /**
     * 使用后序遍历，把指定树x中的所有键放入到keys队列中
     *
     * @param x
     * @param keys
     */
    public void afterErgodic(Node x, Queue keys) {
        //判断x是否为空
        if (x == null) {
            return;
        }

        //递归遍历左节点
        if (x.left != null) {
            afterErgodic(x.left, keys);
        }

        //递归遍历右节点
        if (x.right != null) {
            afterErgodic(x.right, keys);
        }

        //递归遍历首节点
        keys.enqueue(x.key);
    }
```

```
/**
 * 使用后序遍历，获取整个树中的所有键
 *
 * @return
 */
public Queue afterErgodic() {
    Queue<Key> keys = new Queue<>();
    afterErgodic(root, keys);
    return keys;
}

/**
 * 使用后序遍历，把指定树x中的所有键放入到keys队列中
 *
 * @param x
 * @param keys
 */
public void afterErgodic(Node x, Queue keys) {
    //判断x是否为空
    if (x == null) {
        return;
    }

    //递归遍历左节点
    if (x.left != null) {
        afterErgodic(x.left, keys);
    }

    //递归遍历右节点
    if (x.right != null) {
        afterErgodic(x.right, keys);
    }

    //递归遍历首节点
    keys.enqueue(x.key);
}
```

### 二叉树的层序遍历

![](D:\MD文档笔记\img\算法\二叉树层序遍历.png)

那么层序遍历的结果是：EBGADFHC 

我们在创建的树上，添加层序遍历的API： 

`public Queue layerErgodic()：使用层序遍历，获取整个树中的所有键`

实现步骤： 

1.创建队列，存储每一层的结点； 

2.使用循环从队列中弹出一个结点： 

​	2.1获取当前结点的key； 

​	2.2如果当前结点的左子结点不为空，则把左子结点放入到队列中 

​	2.3如果当前结点的右子结点不为空，则把右子结点放入到队列中

![](D:\MD文档笔记\img\算法\二叉树层序遍历流程.png)

**代码:**

```java
/**
     * 使用层序遍历获得树中所有的键
     *
     * @return Queue
     */
    public Queue layerErgodic() {
        //创建2个队列分别存储节点和键的值
        Queue<Key> keys = new Queue<>();
        Queue<Node> nodes = new Queue<>();

        //向队列中放入根节点
        nodes.enqueue(root);

        //判断队列是否还有元素
        while (!nodes.isEmpty()) {
            //弹出一个元素
            Node node = nodes.dequeue();
            //把元素的key放入keys队列中
            keys.enqueue(node.key);
            //判断节点的左子节点不为空就把左子节点放入到队列
            if (node.left != null) {
                nodes.enqueue(node.left);
            }

            //判断节点的右子节点不为空就把右子节点放入到队列
            if (node.right != null) {
                nodes.enqueue(node.right);
            }
        }
        return keys;
    }
```

### 二叉树的最大深度问题

给定一棵树，请计算树的最大深度（树的根节点到最远叶子结点的最长路径上的结点数）；

![](D:\MD文档笔记\img\算法\最大深度.png)



上面这棵树的最大深度为4。

**实现**：

 我们在创建的树上，添加如下的API求最大深度：

`public int maxDepth()：计算整个树的最大深度`

`private int maxDepth(Node x):计算指定树x的最大深度`

**实现步骤**： 

1.如果根结点为空，则最大深度为0； 

2.计算左子树的最大深度； 

3.计算右子树的最大深度； 

4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者**+1**

**代码:**

```java
/**
     * 计算x树的最大深度
     *
     * @param x
     * @return
     */
    private int maxDepth(Node x) {
        //判断x是否为空
        if (x == null) {
            return 0;
        }

        //定义x树的最大深度
        int max = 0;
        //定义left的最大深度
        int maxL = 0;
        //定义right的最大深度
        int maxR = 0;
        
        if (x.left != null) {
            maxL = maxDepth(x.left);
        }

        if (x.right != null) {
            maxR = maxDepth(x.right);
        }
        //找出最大值然后赋值给max
        max = maxL > maxR ? maxL + 1 : maxR + 1;
        //返回max值
        return max;
    }
```

### 折纸问题

​		请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向
指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上
折痕。

给定一个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向

例如：N=1时，打印：down：N=2时，打印：down down up

![](D:\MD文档笔记\img\算法\折纸问题.png)

**分析**

我们把对折后的纸张翻过来，让粉色朝下，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的下折痕就是该结点
的左子结点，而第二次对折产生的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构来描述对折后产生的折痕

这棵树有这样的特点：
	1.根结点为下折痕；

​	2.每一个结点的左子结点为下折痕；

​	3.每一个结点的右子结点为上折痕；

![](D:\MD文档笔记\img\算法\折纸问题-树.png)

**实现步骤：**
	1.定义结点类
	2.构建深度为N的折痕树；
	3.使用中序遍历，打印出树中所有结点的内容；
**构建深度为N的折痕树：**
	1.第一次对折，只有一条折痕，创建根结点；
	2.如果不是第一次对折，则使用队列保存根结点；
	3.循环遍历队列：
		3.1从队列中拿出一个结点；
		3.2如果这个结点的左子结点不为空，则把这个左子结点添加到队列中；
		3.3如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；
		3.4判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个值为down的左子结点，一个值为up的右
子结点。

**代码:**

```java
package cn.doudou.algorithm.test;

import cn.doudou.algorithm.linear.Queue;

/**
 * Create By 王嘉浩
 * Time 2022-11-02 9:00
 * <p>
 * 对于折纸问题的分析与实现
 */
public class PagerFoldingTest {
    public static void main(String[] args) {
        Node<String> tree = createTree(2);
        pintTree(tree);
    }

    public static Node<String> createTree(int N) {
        //通过代码进行模拟产生树
        Node<String> root = null;
        for (int i = 0; i < N; i++) {
            //判断是不是第一次添加
            if (i == 0) {
                root = new Node<>("down", null, null);
                continue;
            }
            //不是第一次进行添加
            Queue<Node> queue = new Queue<>();
            queue.enqueue(root);
            while (!queue.isEmpty()) {
                //弹出一个节点
                Node<String> dequeue = queue.dequeue();
                //判断队列如果有左子节点就把左子节点 放入队列中
                if (dequeue.left != null) {
                    queue.enqueue(dequeue.left);
                }
                //判断队列如果有右子节点就把右子节点 放入队列中
                if (dequeue.right != null) {
                    queue.enqueue(dequeue.right);
                }
                //如果同时没有左子节点和右子节点就需要给他们同时添加左子节点和右子节点
                if (dequeue.left == null && dequeue.right == null) {
                    dequeue.left = new Node("down", null, null);
                    dequeue.right = new Node("up", null, null);
                }
            }
        }
        return root;
    }

    public static void pintTree(Node<String> root) {
        //判断root是否为空
        if (root == null) {
            return;
        }
        //判断是否有左子节点
        if (root.left != null) {
            pintTree(root.left);
        }
        //打印当前节点
        System.out.print(root.item + "  ");

        //判断是否有右子节点
        if (root.right != null) {
            pintTree(root.right);
        }


    }

    //结点类
    private static class Node<T> {
        public T item;//存储元素
        public Node left;
        public Node right;

        public Node(T item, Node left, Node right) {
            this.item = item;
            this.left = left;
            this.right = right;
        }
    }

}
```

## AVL树

- AVL树是最早发明的自平衡二叉搜索树之一
- 平衡因子（Balance Factor）：某结点的左右子树的高度差

### AVL树的特点

- 每个节点的平衡因子只可能是1、0、-1（绝对值<=1，如果超过1，称之为“失衡”）
- 每个节点的左右子树高度差不超过1
- 搜索、添加、删除的时间复杂度是O（logn）

### 基本操作

#### 右旋

- T向右旋转成为L的右结点
- L的右节点Y 放到 T的左孩子上

旋转中心是根节点T的左节点（L）。

![](D:\MD文档笔记\img\算法\AVL\右旋.gif)

#### 左旋

- T向左旋转成为R的左结点
- R的左节点Y放到T的右孩子上

旋转中心是根节点T的右节点（R）。

![](D:\MD文档笔记\img\算法\AVL\左旋.gif)

### 总结

| 插入位置                                              | 状态   | 操作   |
| ----------------------------------------------------- | ------ | ------ |
| 在结点T的左结点（L）的 **左子树（L）** 上做了插入元素 | 左左型 | 右旋   |
| 在结点T的左结点（L）的 **右子树（R）** 上做了插入元素 | 左右型 | 左右旋 |
| 在结点T的右结点（R）的 **右子树（R）** 上做了插入元素 | 右右型 | 左旋   |
| 在结点T的右结点（R）的 **左子树（L）** 上做了插入元素 | 右左型 | 右左旋 |



### 简单的继承结构

![](D:\MD文档笔记\img\算法\AVL\继承.png)



### 主要代码:

```java
package cn.doudou.tree;

import java.util.Comparator;

/**
 * Create By 王嘉浩
 * Time 2022-11-24 16:34
 * <p>
 * AVL树的实现过程
 * <p>
 * 问题一:
 * 如何找到失衡的节点?
 * 其实也是找到一个失衡节点的绝对值!= <=1 对他进行判断是左旋 还是右旋的操作
 * 并且旋转后需要更新parent
 * 和高度的操作
 *
 * <p>
 * 问题二:
 * 如何更新高度?
 * 我们可以在添加后进行对高度进行一个更新
 * 先判断如果添加后没有失衡那我们就更新高度的操作
 * 如果node失衡 那我们就先调整失衡后在更新高度
 * <p>
 * <p>
 * 问题三:
 * 如何对失衡的节点进行调整?
 * 我们在内部类中提供了2个方法
 * 一个是判断是否为左子节点的方法
 * 一个是判断是否为右子节点的方法
 * 我们在根据这2个方法的判断后就可以使用左旋或者是右旋的操作调整
 */
public class AVLTree<E> extends BST<E> {

    public AVLTree() {
        this(null);
    }

    public AVLTree(Comparator<E> comparator) {
        super(comparator);
    }

    @Override
    protected Node<E> createNode(E element, Node<E> parent) {
        return new AVLNode<E>(element, parent);
    }

    @Override
    protected void afterAdd(Node<E> node) {
        while ((node = node.parent) != null) {
            if (isBalanced(node)) {
                //更新高度
                updateHeight(node);
            } else {
                //恢复平衡
                rebalance(node);
                break;
            }
        }
    }

    @Override
    protected void afterRemove(Node<E> node) {
        while ((node = node.parent) != null) {
            if (isBalanced(node)) {
                //更新高度
                updateHeight(node);
            } else {
                //恢复平衡
                rebalance(node);
            }
        }
    }

    /**
     * 使用同一旋转进行恢复平衡
     *
     * @param grand
     */
    private void rebalance(Node<E> grand) {
        Node<E> parent = ((AVLNode<E>) grand).tallerChild();
        Node<E> node = ((AVLNode<E>) grand).tallerChild();
        //旋转方向的判断
        if (parent.isLeftChild()) {//L
            if (node.isLeftChild()) {//LL
                rotate(grand, node.left, node, node.right, parent, parent.right, grand, grand.right);
            } else {//LR
                rotate(grand, parent.left, parent, node.left, node, node.right, grand, grand.right);
            }
        } else {//R
            if (node.isLeftChild()) {//RL
                rotate(grand, grand.left, grand, node.left, node, node.right, parent, parent.right);
            } else {//RR
                rotate(grand, grand.left, grand, parent.left, parent, node.left, node, node.right);
            }
        }

    }

    private void rotate(Node<E> r, //子节点的根节点
                        Node<E> a, Node<E> b, Node<E> c,
                        Node<E> d,
                        Node<E> e, Node<E> f, Node<E> g) {

        //让d成为这棵树的根节点
        d.parent = r.parent;
        if (r.isLeftChild()) {
            r.parent.left = d;
        } else if (r.isRightChild()) {
            r.parent.right = d;
        } else {
            root = d;
        }
        //b-c
        b.left = a;
        if (a != null) {
            a.parent = b;
        }
        b.right = c;
        if (c != null) {
            c.parent = b;
        }
        //修正b的高度
        updateHeight(b);

        //e-g
        f.left = e;
        if (e != null) {
            e.parent = f;
        }
        f.right = g;
        if (g != null) {
            g.parent = f;
        }
        //修正f的高度
        updateHeight(f);

        //修改b和f的parent的指向
        d.left = b;
        d.right = f;
        b.parent = d;
        f.parent = d;
        updateHeight(d);
    }

    /**
     * 恢复平衡
     *
     * @param grand
     */
    private void rebalance2(Node<E> grand) {
        Node<E> parent = ((AVLNode<E>) grand).tallerChild();
        Node<E> node = ((AVLNode<E>) grand).tallerChild();
        //旋转方向的判断
        if (parent.isLeftChild()) {//L
            if (node.isLeftChild()) {//LL
                rotateRight(grand);
            } else {//LR
                rotateLeft(parent);
                rotateRight(grand);
            }
        } else {//R
            if (node.isLeftChild()) {//RL
                rotateRight(parent);
                rotateLeft(grand);
            } else {//RR
                rotateLeft(grand);
            }
        }

    }

    /**
     * 右旋转
     *
     * @param grand
     */
    private void rotateLeft(Node<E> grand) {
        Node<E> parent = grand.right;
        Node<E> child = parent.left;

        grand.right = child;
        parent.left = grand;

        afterRotate(grand, parent, child);
    }

    /**
     * 左旋转
     *
     * @param grand
     */
    private void rotateRight(Node<E> grand) {
        Node<E> parent = grand.left;
        Node<E> child = parent.right;

        grand.left = child;
        parent.right = grand;

        afterRotate(grand, parent, child);
    }

    /**
     * 对添加过后的node 节点的grand、parent、chind的高度和parent进行修复
     *
     * @param grand
     * @param parent
     * @param child
     */
    private void afterRotate(Node<E> grand, Node<E> parent, Node<E> child) {
        // 让parent称为子树的根节点
        parent.parent = grand.parent;
        if (grand.isLeftChild()) {
            grand.parent.left = parent;
        } else if (grand.isRightChild()) {
            grand.parent.right = parent;
        } else { // grand是root节点
            root = parent;
        }

        // 更新child的parent
        if (child != null) {
            child.parent = grand;
        }

        // 更新grand的parent
        grand.parent = parent;

        // 更新高度
        updateHeight(grand);
        updateHeight(parent);
    }

    /**
     * 看下传入进来的node节点是否平衡
     *
     * @param node
     * @return
     */
    private boolean isBalanced(Node<E> node) {
        /**
         * 平衡因子计算  绝对值是小于等于1
         */
        return Math.abs(((AVLNode<E>) node).balanceFactor()) <= 1;
    }

    /**
     * 更新高度操作
     *
     * @param node
     */
    private void updateHeight(Node<E> node) {
        ((AVLNode<E>) node).updateHeight();
    }


    /**
     * AVLNode 内部类 继承 Node
     *
     * @param <E>
     */
    private class AVLNode<E> extends Node<E> {
        int height = 1;

        public AVLNode(E element, Node<E> parent) {
            super(element, parent);
        }

        /**
         * 获得node的平衡因子
         *
         * @return
         */
        public int balanceFactor() {
            int leftH = left == null ? 0 : ((AVLNode<E>) left).height;
            int rightH = right == null ? 0 : ((AVLNode<E>) right).height;
            return leftH - rightH;
        }

        /**
         * 修正node高度
         * <p>
         * 思路:
         * 本身的高度就是 node 的左右节点最大高度+1
         */
        public void updateHeight() {
            int leftH = left == null ? 0 : ((AVLNode<E>) left).height;
            int rightH = right == null ? 0 : ((AVLNode<E>) right).height;
            height = 1 + Math.max(leftH, rightH);
        }


        /**
         * 寻找高度比较高的节点并返回
         *
         * @return
         */
        public Node<E> tallerChild() {
            int leftH = left == null ? 0 : ((AVLNode<E>) left).height;
            int rightH = right == null ? 0 : ((AVLNode<E>) right).height;
            if (leftH > rightH) return left;
            if (leftH < rightH) return right;
            return isLeftChild() ? left : right;
        }

        @Override
        public String toString() {
            String parentString = "null";
            if (parent != null) {
                parentString = parent.element.toString();
            }
            return element + "_p(" + parentString + ")_h(" + height + ")";
        }
    }
}
```

## B树(B-tree、B-树 )

- B树是一种平衡的多路搜索树，多用于文件系统、数据库的实现
- 1个节点可以存储超过2个元素、可以拥有超过2个子节点
- 拥有二叉搜索树的一些性质
- 平衡，每个节点的所有子树高度一致

### B树VS二叉搜索树

- B树和二叉搜索树，在逻辑上是等价的
- 多代节点合并，可以获得一个超级节点

## 红黑树(<font color='red'>Red</font> <font color='black'>Black</font> Tree)

- 红黑树也是一种自平衡的二叉搜索树
- 以前也叫做平衡二叉B树（Symmetric Binary B-tree）
- 红黑树必须满足以下5条性质
  1. 节点是**<font color='red'>RED</font>**或者**<font color='black'>BLACK</font>**
  2. 根节点是**<font color='black'>BLACK</font>**
  3. <font color='orange'>**叶子节点**</font>（外部节点，空节点）都是**BLACK**
  4. **<font color='red'>RED</font>**节点的子节点都是**BLACK**
     1. <font color='red'>**RED**</font>节点的parent都是**BLACK**
     2. 从根节点到<font color='orange'>**叶子节点**</font>不能有2个连续的**<font color='red'>RED</font>**节点
  5. 从任一节点到<font color='orange'>**叶子节点**</font>的所有路径都包含相同数目的BLACK节点 

![](D:\MD文档笔记\img\算法\红黑树\红黑树.png)

### 删除分析:

**B树中，最后真正被删除的元素都在节点中**

1. 删除的是红色节点

   ```
   不进行处理
   ```

   ![](D:\MD文档笔记\img\算法\红黑树\删除-情况一.png)

2. 删除的是黑色节点

   1. 拥有2个红色节点的黑色节点

      ```
      不可能被直接删除，因为会找它的子节点替代删除 也就是前驱节点和后继节点
      ```

      ![](D:\MD文档笔记\img\算法\红黑树\删除-情况二.png)

   2. 拥有一个红色子节点的黑色节点

      ```
      判定条件:用于替代的子节点是红色
      
      将替代的子节点染成BLACK即可保持红黑树性质
      ```

      ![](D:\MD文档笔记\img\算法\红黑树\删除-情况四.png)

   3. 黑色叶子节点

      ```
      判定条件:
      1.兄弟节点至少有一个红色的节点
      2.兄弟节点必须是黑色
      我们如何进行删除?
      	可以考虑兄弟结点可以借一个给我们,黑色叶子节点删除后 会导致B树节点的下溢,进行旋转操作
      
      旋转之后的中心节点继承parent的颜色
      旋转之后的左右节点染为black
      ```

      ```
      判定条件: 
      兄弟是黑色 可以借
      1.兄弟没有一个红色的子节点
      我们如何进行删除?
      	将兄弟节点染成红色,parent染成黑色即可修复红黑树的性质
      
      兄弟是黑色,不可以借
      1.如果parent是黑色
      2.会导致parent也下溢
      如果父节点是红色 让父节点下来进行和兄弟节点进行合并 
      如果父节点是黑色 这时只需要把parent当做被删除的节点处理即可
      
      兄弟是红色 可以借
      判定条件:
      1.如果兄弟为红色
      可以强制让兄弟的子节点变成自己的兄弟 如何进行操作?
      兄弟染成黑色,parent染成红色,可以对父节点进行旋转操作
      ```

      ![](D:\MD文档笔记\img\算法\红黑树\删除-情况三.png)


### 红黑树的平衡

- 那5条性质，可以保证红黑树等价于4阶B树
- 相比AVL树，红黑树的平衡标准比较宽松：没有一条路径会大于其他路径的2倍
- 红黑树的最大高度是2*log2（n+1），依然是O（logn）级别

### 代码:

```java
package cn.doudou.tree;

import com.sun.org.apache.regexp.internal.RE;
import sun.security.x509.RDN;

import java.util.Comparator;

/**
 * Create By 王嘉浩
 * Time 2022-11-28 14:01
 */
public class RBTree<E> extends BBST<E> {
    private static final boolean RED = false;
    private static final boolean BLACK = true;


    public RBTree() {
        this(null);
    }

    public RBTree(Comparator<E> comparator) {
        super(comparator);
    }


    /**
     * 添加
     *
     * @param node 新添加的节点
     */
    @Override
    protected void afterAdd(Node<E> node) {
        Node<E> parent = node.parent;
        //如果是根节点 直接染成black
        if (parent == null) {
            black(node);
            return;
        }

        //如果父节点是黑色不需要进行处理
        if (isBlack(parent)) return;

        // 叔父节点
        Node<E> uncle = parent.sibling();
        // 祖父节点
        Node<E> grand = red(parent.parent);

        //如果父节点是红色
        if (isRed(uncle)) {
            black(parent);
            black(uncle);
            afterAdd(grand);
            return;
        }

        // 叔父节点不是红色
        if (parent.isLeftChild()) {//L
            red(grand);
            if (node.isLeftChild()) {//LL
                black(parent);
            } else {//LR
                black(node);
                rotateLeft(parent);
            }
            rotateRight(grand);
        } else {//R
            red(grand);
            if (node.isLeftChild()) {//RL
                black(node);
                rotateRight(parent);
            } else {//RR
                black(parent);
            }
            rotateLeft(grand);
        }
    }

    /**
     * 重载的删除方法
     *
     * @param node 删除的节点
     */
    @Override
    protected void afterRemove(Node<E> node) {
        //删除的是红色节点
        //if (isRed(node)) return;

        //用于替代的子节点是红色
        if (isRed(node)) {
            black(node);
            return;
        }
        Node<E> parent = node.parent;

        //删除的是根节点
        if (parent == null) return;

        //删除的是黑色叶子节点
        boolean left = parent.left == null || parent.isLeftChild();
        Node<E> sibling = left ? parent.right : parent.left;
        if (left) {//删除的节点在左边 兄弟节点在右边

            if (isRed(sibling)) {//兄弟节点是红色
                black(sibling);
                red(parent);
                rotateLeft(parent);
                //旋转后更换兄弟
                sibling = parent.right;
            }

            //兄弟节点是黑色
            if (isBlack(sibling.left) && isBlack(sibling.right)) {
                //兄弟节点没有一个红色子节点 父节点要向下合并
                boolean parentBlack = isBlack(parent);
                black(parent);
                red(sibling);
                if (parentBlack) {
                    afterRemove(parent);
                }
            } else {//兄弟节点至少有一个红色子节点 向兄弟借
                //兄弟节点左边是黑色 兄弟要先旋转
                if (isBlack(sibling.right)) {
                    rotateRight(sibling);
                    sibling = parent.right;
                }

                //继承父节点的颜色
                color(sibling, colorOf(parent));
                black(sibling.right);
                black(parent);
                rotateLeft(parent);
            }

        } else {//删除的节点在右边 兄弟节点在左边
            if (isRed(sibling)) {//兄弟节点是红色
                black(sibling);
                red(parent);
                rotateRight(parent);
                //旋转后更换兄弟
                sibling = parent.left;
            }

            //兄弟节点是黑色
            if (isBlack(sibling.left) && isBlack(sibling.right)) {
                //兄弟节点没有一个红色子节点 父节点要向下合并
                boolean parentBlack = isBlack(parent);
                red(sibling);
                black(parent);
                if (parentBlack) {
                    afterRemove(parent);
                }
            } else {//兄弟节点至少有一个红色子节点 向兄弟借
                //兄弟节点左边是黑色 兄弟要先旋转
                if (isBlack(sibling.left)) {
                    rotateLeft(sibling);
                    sibling = parent.left;
                }

                //继承父节点的颜色
                color(sibling, colorOf(parent));
                black(sibling.left);
                black(parent);

                rotateRight(parent);
            }


        }

    }

    /**
     * 判断node 节点是否为黑色
     *
     * @param node
     * @return
     */
    private boolean isBlack(Node<E> node) {
        return colorOf(node) == BLACK;
    }

    /**
     * 判断node 节点是否为红色
     *
     * @param node
     * @return
     */
    private boolean isRed(Node<E> node) {
        return colorOf(node) == RED;
    }

    /**
     * 返回指定node的颜色
     *
     * @param node
     * @return
     */
    private boolean colorOf(Node<E> node) {
        return node == null ? BLACK : ((RBNode<E>) node).color;
    }

    /**
     * 指定node染色为红色
     *
     * @param node
     * @return node
     */
    private Node<E> red(Node<E> node) {
        return color(node, RED);
    }

    /**
     * 指定node染色为黑色
     *
     * @param node
     * @return node
     */
    private Node<E> black(Node<E> node) {
        return color(node, BLACK);
    }

    /**
     * 红黑树的染色操作
     * 给定义的node和color 进行染色
     *
     * @param node
     * @param color
     * @return Node<E>
     */
    private Node<E> color(Node<E> node, boolean color) {
        if (node == null) return node;
        ((RBNode<E>) node).color = color;
        return node;
    }

    @Override
    protected Node<E> createNode(E element, Node<E> parent) {
        return new RBNode<>(element, parent);
    }

    /**
     * RBNode 内部类 继承 Node
     *
     * @param <E>
     */
    private class RBNode<E> extends Node<E> {
        boolean color = RED;

        public RBNode(E element, Node<E> parent) {
            super(element, parent);
        }

        @Override
        public String toString() {
            String str = "";
            if (color == RED) {
                str = "R_";
            }
            return str + element.toString();
        }
    }
}

```

### 总结:

1. 添加
   1. 可能会导致所有的祖先节点失衡
   2. 只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡 【仅需O（1）次调整】
2. 删除
   1. 可能会导致父节点或者祖先节点失衡(只有一个节点会失衡)
   2. 让父节点恢复平衡后，可能会导致更高层的祖先节点失衡【最多需要O（ogn）次调整】
3. 平均时间复杂度
   1. 搜索:O(logn)
   2. 添加:O(logn),仅需O(1)次的旋转操作
   3. 删除O(logn),最多需要O(logn)次的旋转操作

## 集合

- 不存放重复的元素
- 常用于去重

### `ListSet Code`

```java
package cn.doudou.set;

import cn.doudou.list.LinkedList;
import cn.doudou.list.List;

/**
 * Create By 王嘉浩
 * Time 2022-12-03 16:05
 * <p>
 * <p>
 * ListSet的设计与实现
 */
public class ListSet<E> implements Set<E> {
    private List<E> list = new LinkedList<E>();

    @Override
    public void clear() {
        list.clear();
    }

    @Override
    public int size() {
        return list.size();
    }

    @Override
    public boolean isEmpty() {
        return list.isEmpty();
    }

    @Override
    public boolean contains(E element) {
        return list.contains(element);
    }

    @Override
    public void add(E element) {
        int index = list.indexOf(element);
        if (index != List.ELEMENT_NOT_FOUND) {
            list.set(index, element);
        } else {
            list.add(element);
        }
    }

    @Override
    public void remove(E element) {
        list.remove(list.indexOf(element));
    }

    @Override
    public void traversal(Visitor<E> visitor) {
        if (visitor == null) return;
        int size = list.size();
        for (int i = 0; i < size; i++) {
            if (visitor.visit(list.get(i))) return;
        }
    }
}

```

### `TreeSet Code`

```java
package cn.doudou.set;

import cn.doudou.tree.BinaryTree;
import cn.doudou.tree.RBTree;

/**
 * Create By 王嘉浩
 * Time 2022-12-03 22:05
 */
public class TreeSet<E> implements Set<E> {
    private RBTree<E> tree = new RBTree<>();

    @Override
    public void clear() {
        tree.clear();
    }

    @Override
    public int size() {
        return tree.size();
    }

    @Override
    public boolean isEmpty() {
        return tree.isEmpty();
    }

    @Override
    public boolean contains(E element) {
        return tree.contains(element);
    }

    @Override
    public void add(E element) {
        tree.add(element);
    }

    @Override
    public void remove(E element) {
        tree.remove(element);
    }

    @Override
    public void traversal(Visitor<E> visitor) {
        tree.inorder(new BinaryTree.Visitor<E>() {
            @Override
            public boolean visit(E element) {
                return visitor.visit(element);
            }
        });

    }
}

```

## 映射Map

- Map在有些编程语言中也叫做字典（dictionary，比如Python、Objective-C、Swift等）
- Map的每一个key是唯一的

## 哈希表 Hash Table

- 哈希表也叫做散列表（hash有“剁碎”的意思）
- 哈希表是【空间换时间】的典型应用
- 哈希函数，也叫做散列函数
- 哈希表内部的数组元素，很多地方也叫Bucket（桶），整个数组叫Buckets或者BucketArray

### 哈希冲突（Hash Collision）

- 哈希冲突也叫做哈希碰撞
- 2个不同的key，经过哈希函数计算出相同的结果

### 解决哈希冲突的常见方法

- 开放定址法（Open Addressing）
  按照一定规则向其他地址探测，直到遇到空桶

- 再哈希法（Re-Hashing）

  设计多个哈希函数

- 链地址法（Separate Chaining）

  比如通过链表将同一index的元素串起来

### JDK1.8的哈希冲突解决方案

- 默认使用单向链表将元素串起来
- 在添加元素时，可能会由单向链表转为红黑树来存储元素
- 比如当哈希表容量>=64且单向链表的节点数量大于8时
- 当红黑树节点数量少到一定程度时，又会转为单向链表
- JDK1.8中的哈希表是使用链表+红黑树解决哈希冲突

### 哈希函数

1. 先生成key的哈希值（必须是整数）
2. 再让key的哈希值跟数组的大小进行相关运算，生成一个索引值

### 代码实现

`Map接口设计`

```java
package cn.doudou.map;


/**
 * Create By 王嘉浩
 * Time 2022-12-04 10:38
 */
public interface Map<K, V> {
    int size();

    boolean isEmpty();

    void clear();

    V put(K key, V value);

    V get(K key);

    V remove(K key);

    boolean containsKey(K key);

    boolean containsValue(V value);

    void traversal(Visitor<K, V> visitor);


    public static abstract class Visitor<K, V> {
        boolean stop;

        public abstract boolean visit(K key, V value);
    }

}

```

`HashMap实现类`

```java
package cn.doudou.map;

import cn.doudou.map.Map;
import cn.doudou.printer.BinaryTreeInfo;
import cn.doudou.printer.BinaryTrees;
import com.sun.org.apache.xpath.internal.objects.XNodeSet;

import java.util.LinkedList;
import java.util.Objects;
import java.util.Queue;

/**
 * Create By 王嘉浩
 * Time 2022-12-07 14:20
 */
public class HashMap<K, V> implements Map<K, V> {
    private int size;
    private static final boolean RED = false;
    private static final boolean BLACK = true;
    //hash表的存储的根节点
    private Node<K, V>[] table;
    //默认容量
    private static final int DEFAULT_CAPACITY = 1 << 4;
    //装填因子
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;

    public HashMap() {
        table = new Node[DEFAULT_CAPACITY];
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public void clear() {
        if (size == 0) return;
        for (int i = 0; i < table.length; i++) {
            table[i] = null;
        }
        size = 0;

    }


    @Override
    public V put(K key, V value) {
        resize();
        int index = index(key);
        Node<K, V> root = table[index];
        if (root == null) {//代表没有元素
            root = new Node<>(key, value, null);
            table[index] = root;
            size++;
            afterPut(root);
            return null;
        }

        //添加新的节点到红黑树上面
        Node<K, V> parent = root;
        Node<K, V> node = root;
        int cmp = 0;
        K k1 = key;
        Node<K, V> resultNode = null;
        boolean searched = false;
        int h1 = hash(key);
        do {
            parent = node;
            K k2 = node.key;
            int h2 = node.hash;
            if (h1 > h2) {//向右边找
                cmp = 1;
            } else if (h1 < h2) {//向左边找
                cmp = -1;
            } else if (Objects.equals(k1, k2)) {
                cmp = 0;
            } else if (k1 != null && k2 != null
                    && k1 instanceof Comparable
                    && k1.getClass() == k2.getClass()
                    && (cmp = ((Comparable) k1).compareTo(k2)) != 0) {

            } else if (searched) {//searched == true
                cmp = System.identityHashCode(k1) - System.identityHashCode(k2);
            } else {//hash值相等,不equals,不具备可比较性
                /**
                 * 递归的调用node传入左右子节点去中查找k1是否在里面
                 * 是的话就覆盖
                 * 不是的就可以使用内存地址进行相减
                 */
                if ((node.left != null && (resultNode = node(node.left, k1)) != null)
                        || (node.right != null && (resultNode = node(node.right, k1)) != null)) {
                    node = resultNode;
                    cmp = 0;
                } else {
                    searched = true;
                    cmp = System.identityHashCode(k1) - System.identityHashCode(k2);
                }
            }


            if (cmp > 0) {
                node = node.right;
            } else if (cmp < 0) {
                node = node.left;
            } else { // 相等
                V oldValue = node.value;
                node.key = key;
                node.value = value;
                node.hash = h1;
                return oldValue;
            }
        } while (node != null);

        // 看看插入到父节点的哪个位置
        Node<K, V> newNode = new Node<>(key, value, parent);
        if (cmp > 0) {
            parent.right = newNode;
        } else {
            parent.left = newNode;
        }
        size++;

        // 新添加节点之后的处理
        afterPut(newNode);
        return null;
    }

    @Override
    public V get(K key) {
        Node<K, V> node = node(key);
        return node != null ? node.value : null;
    }

    @Override
    public V remove(K key) {
        return remove(node(key));
    }

    @Override
    public boolean containsKey(K key) {
        return node(key) != null;
    }

    @Override
    public boolean containsValue(V value) {
        //size == 0 return false;
        if (size == 0) return false;
        //层序遍历
        Queue<Node<K, V>> queue = new LinkedList<>();
        for (int i = 0; i < table.length; i++) {
            if (table[i] == null) continue;
            queue.offer(table[i]);
            while (!queue.isEmpty()) {
                Node<K, V> node = queue.poll();

                if (Objects.equals(value, node.value)) return true;

                if (node.left != null) {
                    queue.offer(node.left);
                }

                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }
        return false;
    }

    @Override
    public void traversal(Visitor<K, V> visitor) {
        if (size == 0 || visitor == null) return;
        //层序遍历
        Queue<Node<K, V>> queue = new LinkedList<>();
        for (int i = 0; i < table.length; i++) {
            if (table[i] == null) continue;
            queue.offer(table[i]);
            while (!queue.isEmpty()) {
                Node<K, V> node = queue.poll();

                if (visitor.visit(node.key, node.value)) return;

                if (node.left != null) {
                    queue.offer(node.left);
                }

                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }
    }

    /**
     * 扩容
     */
    private void resize() {
        //计算装填因子 <= 0.75f
        if ((size / table.length) <= DEFAULT_LOAD_FACTOR) return;

        Node<K, V>[] oldTable = this.table;
        table = new Node[oldTable.length << 1];

        Queue<Node<K, V>> queue = new LinkedList<>();
        for (int i = 0; i < oldTable.length; i++) {
            if (oldTable[i] == null) continue;
            queue.offer(oldTable[i]);
            while (!queue.isEmpty()) {
                Node<K, V> node = queue.poll();
                if (node.left != null) {
                    queue.offer(node.left);
                }

                if (node.right != null) {
                    queue.offer(node.right);
                }
                moveNode(node);
            }
        }
    }

    /**
     * 挪动代码
     *
     * @param newNode
     */
    private void moveNode(Node<K, V> newNode) {
        //重置
        newNode.parent = null;
        newNode.left = null;
        newNode.right = null;
        newNode.color = RED;

        //计算索引
        int index = index(newNode);
        Node<K, V> root = table[index];
        if (root == null) {
            root = newNode;
            table[index] = root;
            afterPut(root);
            return;
        }

        //添加新的节点到红黑树上
        Node<K, V> parent = root;
        Node<K, V> node = root;
        int cmp = 0;
        K k1 = newNode.key;
        int h1 = newNode.hash;
        do {
            parent = node;
            K k2 = node.key;
            int h2 = node.hash;
            if (h1 > h2) {
                cmp = 1;
            } else if (h1 < h2) {
                cmp = -1;
            } else if (k1 != null && k2 != null
                    && k1 instanceof Comparable
                    && k1.getClass() == k2.getClass()
                    && (cmp = ((Comparable) k1).compareTo(k2)) != 0) {
            } else {
                cmp = System.identityHashCode(k1) - System.identityHashCode(k2);
            }

            if (cmp > 0) {
                node = node.right;
            } else if (cmp < 0) {
                node = node.left;
            }
        } while (node != null);

        // 看看插入到父节点的哪个位置
        newNode.parent = parent;
        if (cmp > 0) {
            parent.right = newNode;
        } else {
            parent.left = newNode;
        }

        // 新添加节点之后的处理
        afterPut(newNode);

    }

    private int hash(K key) {
        if (key == null) return 0;
        int hash = key.hashCode();
        return hash ^ (hash >>> 16);
    }

    private V remove(Node<K, V> node) {
        if (node == null) return null;
        size--;
        V oldValue = node.value;
        if (node.hasTwoChildren()) { // 度为2的节点
            // 找到后继节点
            Node<K, V> s = successor(node);
            // 用后继节点的值覆盖度为2的节点的值
            node.key = s.key;
            node.value = s.value;
            node.hash = s.hash;
            // 删除后继节点
            node = s;
        }

        // 删除node节点（node的度必然是1或者0）
        Node<K, V> replacement = node.left != null ? node.left : node.right;
        int index = index(node);

        if (replacement != null) { // node是度为1的节点
            // 更改parent
            replacement.parent = node.parent;
            // 更改parent的left、right的指向
            if (node.parent == null) { // node是度为1的节点并且是根节点
                table[index] = replacement;
            } else if (node == node.parent.left) {
                node.parent.left = replacement;
            } else { // node == node.parent.right
                node.parent.right = replacement;
            }
        } else if (node.parent == null) { // node是叶子节点并且是根节点
            table[index] = null;
        } else { // node是叶子节点，但不是根节点
            if (node == node.parent.left) {
                node.parent.left = null;
            } else { // node == node.parent.right
                node.parent.right = null;
            }

        }
        return oldValue;
    }

    private Node<K, V> successor(Node<K, V> node) {
        if (node == null) return null;

        // 前驱节点在左子树当中（right.left.left.left....）
        Node<K, V> p = node.right;
        if (p != null) {
            while (p.left != null) {
                p = p.left;
            }
            return p;
        }

        // 从父节点、祖父节点中寻找前驱节点
        while (node.parent != null && node == node.parent.right) {
            node = node.parent;
        }

        return node.parent;
    }

    private Node<K, V> node(K key) {
        Node<K, V> root = table[index(key)];
        return root == null ? null : node(root, key);
    }

    private Node<K, V> node(Node<K, V> node, K k1) {
        int h1 = hash(k1);
        //返回结果
        Node<K, V> resultNode = null;
        int cmp = 0;
        while (node != null) {
            K k2 = node.key;
            int h2 = node.hash;
            //先比较hash值
            if (h1 > h2) {//向右边找
                node = node.right;
            } else if (h1 < h2) {//向左边找
                node = node.left;
            } else if (Objects.equals(k1, k2)) {//代表k1 == k2
                return node;
            } else if (k1 != null && k2 != null
                    && k1 instanceof Comparable
                    && k1.getClass() == k2.getClass()
                    && (cmp = ((Comparable) k1).compareTo(k2)) != 0) {
                node = cmp > 0 ? node.right : node.left;
            } else if (node.right != null
                    && (resultNode = node(node.right, k1)) != null) {//hash值相等,不具备可比较性,也不equals
                return resultNode;
            } else {
                node = node.left;
            }
        }
        return null;
    }


    /**
     * 比较大小
     *
     * @param k1
     * @param k2
     * @param h1 k1的hashCode
     * @param h2 k2的hashCode
     * @return 0 | 1 | -1
     */
    private int compare(K k1, K k2, int h1, int h2) {
        //1.先比较hash
        int result = h1 - h2;
        //h1-h2的值不为0 就代表一个大一个小
        if (result != 0) return result;

        //2.比较是否相等
        //来到这里代表h1和h2的hash相等  我们只需要查看他们2个的equals是否相等即可
        if (Objects.equals(k1, k2)) return 0;

        //3.hash值相等但是equals不相等
        //可以使用比较类名
        if (k1 != null && k2 != null) {
            String k1Cls = k1.getClass().getName();
            String k2Cls = k2.getClass().getName();
            result = k1Cls.compareTo(k2Cls);
            if (result != 0) return result;

            //同一种类型具有可比较性
            if (k1 instanceof Comparable) {
                return ((Comparable) k1).compareTo(k2);
            }
        }

        //4.实在是没有办法进行比较了
        //使用内存地址进行计算
        return System.identityHashCode(k1) - System.identityHashCode(k2);
    }

    private void afterPut(Node<K, V> node) {
        Node<K, V> parent = node.parent;

        // 添加的是根节点 或者 上溢到达了根节点
        if (parent == null) {
            black(node);
            return;
        }

        // 如果父节点是黑色，直接返回
        if (isBlack(parent)) return;

        // 叔父节点
        Node<K, V> uncle = parent.sibling();
        // 祖父节点
        Node<K, V> grand = red(parent.parent);
        if (isRed(uncle)) { // 叔父节点是红色【B树节点上溢】
            black(parent);
            black(uncle);
            // 把祖父节点当做是新添加的节点
            afterPut(grand);
            return;
        }

        // 叔父节点不是红色
        if (parent.isLeftChild()) { // L
            if (node.isLeftChild()) { // LL
                black(parent);
            } else { // LR
                black(node);
                rotateLeft(parent);
            }
            rotateRight(grand);
        } else { // R
            if (node.isLeftChild()) { // RL
                black(node);
                rotateRight(parent);
            } else { // RR
                black(parent);
            }
            rotateLeft(grand);
        }
    }

    private Node<K, V> color(Node<K, V> node, boolean color) {
        if (node == null) return node;
        node.color = color;
        return node;
    }

    private void rotateLeft(Node<K, V> grand) {
        Node<K, V> parent = grand.right;
        Node<K, V> child = parent.left;
        grand.right = child;
        parent.left = grand;
        afterRotate(grand, parent, child);
    }

    private void rotateRight(Node<K, V> grand) {
        Node<K, V> parent = grand.left;
        Node<K, V> child = parent.right;
        grand.left = child;
        parent.right = grand;
        afterRotate(grand, parent, child);
    }

    private void afterRotate(Node<K, V> grand, Node<K, V> parent, Node<K, V> child) {
        // 让parent称为子树的根节点
        parent.parent = grand.parent;
        if (grand.isLeftChild()) {
            grand.parent.left = parent;
        } else if (grand.isRightChild()) {
            grand.parent.right = parent;
        } else { // grand是root节点
            table[index(grand)] = parent;
        }

        // 更新child的parent
        if (child != null) {
            child.parent = grand;
        }

        // 更新grand的parent
        grand.parent = parent;
    }

    private Node<K, V> red(Node<K, V> node) {
        return color(node, RED);
    }

    private Node<K, V> black(Node<K, V> node) {
        return color(node, BLACK);
    }

    private boolean colorOf(Node<K, V> node) {
        return node == null ? BLACK : node.color;
    }

    private boolean isBlack(Node<K, V> node) {
        return colorOf(node) == BLACK;
    }

    private boolean isRed(Node<K, V> node) {
        return colorOf(node) == RED;
    }

    /**
     * 根对应传入的key生成响应的索引
     *
     * @param key
     * @return int
     */
    private int index(K key) {
        return hash(key) & (table.length - 1);
    }

    private int index(Node<K, V> node) {
        return node.hash & (table.length - 1);
    }

    public void print() {
        if (size == 0) return;
        for (int i = 0; i < table.length; i++) {
            final Node<K, V> root = table[i];
            System.out.println("【index = " + i + "】");
            BinaryTrees.println(new BinaryTreeInfo() {
                @Override
                public Object string(Object node) {
                    return node;
                }

                @Override
                public Object root() {
                    return root;
                }

                @Override
                public Object right(Object node) {
                    return ((Node<K, V>) node).right;
                }

                @Override
                public Object left(Object node) {
                    return ((Node<K, V>) node).left;
                }
            });
            System.out.println("---------------------------------------------------");
        }
    }

    private static class Node<K, V> {
        int hash;
        K key;
        V value;
        boolean color = RED;
        Node<K, V> left;
        Node<K, V> right;
        Node<K, V> parent;

        public Node(K key, V value, Node<K, V> parent) {
            this.key = key;
            int hash = key == null ? 0 : key.hashCode();
            this.hash = hash ^ (hash >>> 16);
            this.value = value;
            this.parent = parent;
        }

        public boolean hasTwoChildren() {
            return left != null && right != null;
        }

        public boolean isLeftChild() {
            return parent != null && this == parent.left;
        }

        public boolean isRightChild() {
            return parent != null && this == parent.right;
        }

        public Node<K, V> sibling() {
            if (isLeftChild()) {
                return parent.right;
            }

            if (isRightChild()) {
                return parent.left;
            }

            return null;
        }

        @Override
        public String toString() {
            return "K->" + key + "_V->" + value;
        }
    }
}
```

## 堆 Heap

堆（Heap）也是一种树状的数据结构（不要跟陶存模型中的“堆空间混滑），常见的堆实现有

二叉堆（BinaryHeap，完全二叉堆）
多叉堆（D-heap、D-aryHeap）
索引堆（IndexHeap）
二项堆（BinomialHeap）
斐波那契堆（FibonacciHeap）
左倾堆（LeftistHeap，左式堆）
斜堆（SkewHeap）

堆的一个重要性质：任意节点的值总是>=（≤）子节点的值

如果任意节点的值总是2子节点的值，称为：最大堆、大根堆、大顶堆

如果任意节点的值总是≤子节点的值，称为：最小堆、小根堆、小顶堆



